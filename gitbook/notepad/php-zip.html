
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>PHP打包源码 · Blog</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-disqus/plugin.css">
                
            
        

    

    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="webshell.html" />
    
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
            
                <nav role="navigation">
                


<ul class="summary">
    
    
    
        
        <li>
            <a href="https://webpack.weapp.cc/webpack/index.html" target="_blank" class="custom-link">webpack</a>
        </li>
    
    

    
    <li class="divider"></li>
    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    前言
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    PHP
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="../php/reflection-demo.html">
            
                <a href="../php/reflection-demo.html">
            
                    
                    PHP反射
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="../php/rpc.html">
            
                <a href="../php/rpc.html">
            
                    
                    简单TCP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="../php/buffer.html">
            
                <a href="../php/buffer.html">
            
                    
                    输出流
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="../php/pcntl.html">
            
                <a href="../php/pcntl.html">
            
                    
                    协程
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    前端
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" >
            
                <span>
            
                    
                    VUE
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1.1" data-path="../front/vue/vue_config.html">
            
                <a href="../front/vue/vue_config.html">
            
                    
                    vue配置
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Docker
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../docker/base.html">
            
                <a href="../docker/base.html">
            
                    
                    Docker环境下的前后端分离部署与运维
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../docker/compose.html">
            
                <a href="../docker/compose.html">
            
                    
                    Docker compose
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" >
            
                <span>
            
                    
                    环境
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="node_v8.html">
            
                <a href="node_v8.html">
            
                    
                    node v8.0版本
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="nginx_proxy.html">
            
                <a href="nginx_proxy.html">
            
                    
                    Nginx 代理
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="v8js.html">
            
                <a href="v8js.html">
            
                    
                    编译V8JS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="sodium.html">
            
                <a href="sodium.html">
            
                    
                    编译sodium
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" >
            
                <span>
            
                    
                    杂项
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" >
            
                <span>
            
                    
                    IOS
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1.1" data-path="build_ios_key.html">
            
                <a href="build_ios_key.html">
            
                    
                    生成IPA证书
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6.2" >
            
                <span>
            
                    
                    后门
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="1.6.2.1" data-path="php-zip.html">
            
                <a href="php-zip.html">
            
                    
                    PHP打包源码
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.2" data-path="webshell.html">
            
                <a href="webshell.html">
            
                    
                    PHPshell
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2.3" data-path="xss.html">
            
                <a href="xss.html">
            
                    
                    xss脚本
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="win10_repair.html">
            
                <a href="win10_repair.html">
            
                    
                    win10应用修复
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            本书使用 GitBook 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >PHP打包源码</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
                                <section class="normal markdown-section">
                                
                                <pre><code>&lt;?php
set_time_limit(0);
ignore_user_abort(true);
is_file(&apos;mccc.zip&apos;) &amp;&amp; unlink(&apos;mccc.zip&apos;);
// --------------------------------------------------------------------------------
// PhpConcept Library - Zip Module 2.8.2
// --------------------------------------------------------------------------------
// License GNU/LGPL - Vincent Blavet - August 2009
// http://www.phpconcept.net
// --------------------------------------------------------------------------------
//
// Presentation :
//   PclZip is a PHP library that manage ZIP archives.
//   So far tests show that archives generated by PclZip are readable by
//   WinZip application and other tools.
//
// Description :
//   See readme.txt and http://www.phpconcept.net
//
// Warning :
//   This library and the associated files are non commercial, non professional
//   work.
//   It should not have unexpected results. However if any damage is caused by
//   this software the author can not be responsible.
//   The use of this software is at the risk of the user.
//
// --------------------------------------------------------------------------------
// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $
// --------------------------------------------------------------------------------

// ----- Constants
if (!defined(&apos;PCLZIP_READ_BLOCK_SIZE&apos;)) {
    define(&apos;PCLZIP_READ_BLOCK_SIZE&apos;, 2048);
}

// ----- File list separator
// In version 1.x of PclZip, the separator for file list is a space
// (which is not a very smart choice, specifically for windows paths !).
// A better separator should be a comma (,). This constant gives you the
// abilty to change that.
// However notice that changing this value, may have impact on existing
// scripts, using space separated filenames.
// Recommanded values for compatibility with older versions :
//define( &apos;PCLZIP_SEPARATOR&apos;, &apos; &apos; );
// Recommanded values for smart separation of filenames.
if (!defined(&apos;PCLZIP_SEPARATOR&apos;)) {
    define(&apos;PCLZIP_SEPARATOR&apos;, &apos;,&apos;);
}

// ----- Error configuration
// 0 : PclZip Class integrated error handling
// 1 : PclError external library error handling. By enabling this
//     you must ensure that you have included PclError library.
// [2,...] : reserved for futur use
if (!defined(&apos;PCLZIP_ERROR_EXTERNAL&apos;)) {
    define(&apos;PCLZIP_ERROR_EXTERNAL&apos;, 0);
}

// ----- Optional static temporary directory
//       By default temporary files are generated in the script current
//       path.
//       If defined :
//       - MUST BE terminated by a &apos;/&apos;.
//       - MUST be a valid, already created directory
//       Samples :
// define( &apos;PCLZIP_TEMPORARY_DIR&apos;, &apos;/temp/&apos; );
// define( &apos;PCLZIP_TEMPORARY_DIR&apos;, &apos;C:/Temp/&apos; );
if (!defined(&apos;PCLZIP_TEMPORARY_DIR&apos;)) {
    define(&apos;PCLZIP_TEMPORARY_DIR&apos;, &apos;&apos;);
}

// ----- Optional threshold ratio for use of temporary files
//       Pclzip sense the size of the file to add/extract and decide to
//       use or not temporary file. The algorythm is looking for
//       memory_limit of PHP and apply a ratio.
//       threshold = memory_limit * ratio.
//       Recommended values are under 0.5. Default 0.47.
//       Samples :
// define( &apos;PCLZIP_TEMPORARY_FILE_RATIO&apos;, 0.5 );
if (!defined(&apos;PCLZIP_TEMPORARY_FILE_RATIO&apos;)) {
    define(&apos;PCLZIP_TEMPORARY_FILE_RATIO&apos;, 0.47);
}

// --------------------------------------------------------------------------------
// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****
// --------------------------------------------------------------------------------

// ----- Global variables
$g_pclzip_version = &quot;2.8.2&quot;;

// ----- Error codes
//   -1 : Unable to open file in binary write mode
//   -2 : Unable to open file in binary read mode
//   -3 : Invalid parameters
//   -4 : File does not exist
//   -5 : Filename is too long (max. 255)
//   -6 : Not a valid zip file
//   -7 : Invalid extracted file size
//   -8 : Unable to create directory
//   -9 : Invalid archive extension
//  -10 : Invalid archive format
//  -11 : Unable to delete file (unlink)
//  -12 : Unable to rename file (rename)
//  -13 : Invalid header checksum
//  -14 : Invalid archive size
define(&apos;PCLZIP_ERR_USER_ABORTED&apos;, 2);
define(&apos;PCLZIP_ERR_NO_ERROR&apos;, 0);
define(&apos;PCLZIP_ERR_WRITE_OPEN_FAIL&apos;, -1);
define(&apos;PCLZIP_ERR_READ_OPEN_FAIL&apos;, -2);
define(&apos;PCLZIP_ERR_INVALID_PARAMETER&apos;, -3);
define(&apos;PCLZIP_ERR_MISSING_FILE&apos;, -4);
define(&apos;PCLZIP_ERR_FILENAME_TOO_LONG&apos;, -5);
define(&apos;PCLZIP_ERR_INVALID_ZIP&apos;, -6);
define(&apos;PCLZIP_ERR_BAD_EXTRACTED_FILE&apos;, -7);
define(&apos;PCLZIP_ERR_DIR_CREATE_FAIL&apos;, -8);
define(&apos;PCLZIP_ERR_BAD_EXTENSION&apos;, -9);
define(&apos;PCLZIP_ERR_BAD_FORMAT&apos;, -10);
define(&apos;PCLZIP_ERR_DELETE_FILE_FAIL&apos;, -11);
define(&apos;PCLZIP_ERR_RENAME_FILE_FAIL&apos;, -12);
define(&apos;PCLZIP_ERR_BAD_CHECKSUM&apos;, -13);
define(&apos;PCLZIP_ERR_INVALID_ARCHIVE_ZIP&apos;, -14);
define(&apos;PCLZIP_ERR_MISSING_OPTION_VALUE&apos;, -15);
define(&apos;PCLZIP_ERR_INVALID_OPTION_VALUE&apos;, -16);
define(&apos;PCLZIP_ERR_ALREADY_A_DIRECTORY&apos;, -17);
define(&apos;PCLZIP_ERR_UNSUPPORTED_COMPRESSION&apos;, -18);
define(&apos;PCLZIP_ERR_UNSUPPORTED_ENCRYPTION&apos;, -19);
define(&apos;PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE&apos;, -20);
define(&apos;PCLZIP_ERR_DIRECTORY_RESTRICTION&apos;, -21);

// ----- Options values
define(&apos;PCLZIP_OPT_PATH&apos;, 77001);
define(&apos;PCLZIP_OPT_ADD_PATH&apos;, 77002);
define(&apos;PCLZIP_OPT_REMOVE_PATH&apos;, 77003);
define(&apos;PCLZIP_OPT_REMOVE_ALL_PATH&apos;, 77004);
define(&apos;PCLZIP_OPT_SET_CHMOD&apos;, 77005);
define(&apos;PCLZIP_OPT_EXTRACT_AS_STRING&apos;, 77006);
define(&apos;PCLZIP_OPT_NO_COMPRESSION&apos;, 77007);
define(&apos;PCLZIP_OPT_BY_NAME&apos;, 77008);
define(&apos;PCLZIP_OPT_BY_INDEX&apos;, 77009);
define(&apos;PCLZIP_OPT_BY_EREG&apos;, 77010);
define(&apos;PCLZIP_OPT_BY_PREG&apos;, 77011);
define(&apos;PCLZIP_OPT_COMMENT&apos;, 77012);
define(&apos;PCLZIP_OPT_ADD_COMMENT&apos;, 77013);
define(&apos;PCLZIP_OPT_PREPEND_COMMENT&apos;, 77014);
define(&apos;PCLZIP_OPT_EXTRACT_IN_OUTPUT&apos;, 77015);
define(&apos;PCLZIP_OPT_REPLACE_NEWER&apos;, 77016);
define(&apos;PCLZIP_OPT_STOP_ON_ERROR&apos;, 77017);
// Having big trouble with crypt. Need to multiply 2 long int
// which is not correctly supported by PHP ...
//define( &apos;PCLZIP_OPT_CRYPT&apos;, 77018 );
define(&apos;PCLZIP_OPT_EXTRACT_DIR_RESTRICTION&apos;, 77019);
define(&apos;PCLZIP_OPT_TEMP_FILE_THRESHOLD&apos;, 77020);
define(&apos;PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD&apos;, 77020); // alias
define(&apos;PCLZIP_OPT_TEMP_FILE_ON&apos;, 77021);
define(&apos;PCLZIP_OPT_ADD_TEMP_FILE_ON&apos;, 77021); // alias
define(&apos;PCLZIP_OPT_TEMP_FILE_OFF&apos;, 77022);
define(&apos;PCLZIP_OPT_ADD_TEMP_FILE_OFF&apos;, 77022); // alias

// ----- File description attributes
define(&apos;PCLZIP_ATT_FILE_NAME&apos;, 79001);
define(&apos;PCLZIP_ATT_FILE_NEW_SHORT_NAME&apos;, 79002);
define(&apos;PCLZIP_ATT_FILE_NEW_FULL_NAME&apos;, 79003);
define(&apos;PCLZIP_ATT_FILE_MTIME&apos;, 79004);
define(&apos;PCLZIP_ATT_FILE_CONTENT&apos;, 79005);
define(&apos;PCLZIP_ATT_FILE_COMMENT&apos;, 79006);

// ----- Call backs values
define(&apos;PCLZIP_CB_PRE_EXTRACT&apos;, 78001);
define(&apos;PCLZIP_CB_POST_EXTRACT&apos;, 78002);
define(&apos;PCLZIP_CB_PRE_ADD&apos;, 78003);
define(&apos;PCLZIP_CB_POST_ADD&apos;, 78004);
/* For futur use
define( &apos;PCLZIP_CB_PRE_LIST&apos;, 78005 );
define( &apos;PCLZIP_CB_POST_LIST&apos;, 78006 );
define( &apos;PCLZIP_CB_PRE_DELETE&apos;, 78007 );
define( &apos;PCLZIP_CB_POST_DELETE&apos;, 78008 );
*/

// --------------------------------------------------------------------------------
// Class : PclZip
// Description :
//   PclZip is the class that represent a Zip archive.
//   The public methods allow the manipulation of the archive.
// Attributes :
//   Attributes must not be accessed directly.
// Methods :
//   PclZip() : Object creator
//   create() : Creates the Zip archive
//   listContent() : List the content of the Zip archive
//   extract() : Extract the content of the archive
//   properties() : List the properties of the archive
// --------------------------------------------------------------------------------

$archive = new PclZip(&apos;mccc.zip&apos;);
$v_list = $archive-&gt;create([&apos;/www/wwwroot/path&apos;],PCLZIP_OPT_REMOVE_PATH, &quot;/www/wwwroot/path&quot;);
 //
if ($v_list == 0) {
    die(&quot;Error : &quot;.$archive-&gt;errorInfo(true));
}
class PclZip
{
    // ----- Filename of the zip file
    public $zipname = &apos;&apos;;

    // ----- File descriptor of the zip file
    public $zip_fd = 0;

    // ----- Internal error handling
    public $error_code = 1;
    public $error_string = &apos;&apos;;

    // ----- Current status of the magic_quotes_runtime
    // This value store the php configuration for magic_quotes
    // The class can then disable the magic_quotes and reset it after
    public $magic_quotes_status;

    // --------------------------------------------------------------------------------
    // Function : PclZip()
    // Description :
    //   Creates a PclZip object and set the name of the associated Zip archive
    //   filename.
    //   Note that no real action is taken, if the archive does not exist it is not
    //   created. Use create() for that.
    // --------------------------------------------------------------------------------
    public function __construct($p_zipname)
    {

        // ----- Tests the zlib
        if (!function_exists(&apos;gzopen&apos;)) {
            die(&apos;Abort &apos; . basename(__FILE__) . &apos; : Missing zlib extensions&apos;);
        }

        // ----- Set the attributes
        $this-&gt;zipname             = $p_zipname;
        $this-&gt;zip_fd              = 0;
        $this-&gt;magic_quotes_status = -1;

        // ----- Return
        return;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function :
    //   create($p_filelist, $p_add_dir=&quot;&quot;, $p_remove_dir=&quot;&quot;)
    //   create($p_filelist, $p_option, $p_option_value, ...)
    // Description :
    //   This method supports two different synopsis. The first one is historical.
    //   This method creates a Zip Archive. The Zip file is created in the
    //   filesystem. The files and directories indicated in $p_filelist
    //   are added in the archive. See the parameters description for the
    //   supported format of $p_filelist.
    //   When a directory is in the list, the directory and its content is added
    //   in the archive.
    //   In this synopsis, the function takes an optional variable list of
    //   options. See bellow the supported options.
    // Parameters :
    //   $p_filelist : An array containing file or directory names, or
    //                 a string containing one filename or one directory name, or
    //                 a string containing a list of filenames and/or directory
    //                 names separated by spaces.
    //   $p_add_dir : A path to add before the real path of the archived file,
    //                in order to have it memorized in the archive.
    //   $p_remove_dir : A path to remove from the real path of the file to archive,
    //                   in order to have a shorter path memorized in the archive.
    //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir
    //                   is removed first, before $p_add_dir is added.
    // Options :
    //   PCLZIP_OPT_ADD_PATH :
    //   PCLZIP_OPT_REMOVE_PATH :
    //   PCLZIP_OPT_REMOVE_ALL_PATH :
    //   PCLZIP_OPT_COMMENT :
    //   PCLZIP_CB_PRE_ADD :
    //   PCLZIP_CB_POST_ADD :
    // Return Values :
    //   0 on failure,
    //   The list of the added files, with a status of the add action.
    //   (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    public function create($p_filelist)
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Set default values
        $v_options                            = array();
        $v_options[PCLZIP_OPT_NO_COMPRESSION] = false;

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Look for arguments
        if ($v_size &gt; 1) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Remove from the options list the first argument
            array_shift($v_arg_list);
            $v_size--;

            // ----- Look for first arg
            if ((is_integer($v_arg_list[0])) &amp;&amp; ($v_arg_list[0] &gt; 77000)) {

                // ----- Parse the options
                $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, array(
                    PCLZIP_OPT_REMOVE_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_REMOVE_ALL_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_ADD_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_CB_PRE_ADD =&gt; &apos;optional&apos;,
                    PCLZIP_CB_POST_ADD =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_NO_COMPRESSION =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_COMMENT =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_THRESHOLD =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_ON =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_OFF =&gt; &apos;optional&apos;
                    //, PCLZIP_OPT_CRYPT =&gt; &apos;optional&apos;
                ));
                if ($v_result != 1) {
                    return 0;
                }

            // ----- Look for 2 args
            // Here we need to support the first historic synopsis of the
            // method.
            } else {

                // ----- Get the first argument
                $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];

                // ----- Look for the optional second argument
                if ($v_size == 2) {
                    $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];
                } elseif ($v_size &gt; 2) {
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid number / type of arguments&quot;);

                    return 0;
                }
            }
        }

        // ----- Look for default option values
        $this-&gt;privOptionDefaultThreshold($v_options);

        // ----- Init
        $v_string_list    = array();
        $v_att_list       = array();
        $v_filedescr_list = array();
        $p_result_list    = array();

        // ----- Look if the $p_filelist is really an array
        if (is_array($p_filelist)) {

            // ----- Look if the first element is also an array
            //       This will mean that this is a file description entry
            if (isset($p_filelist[0]) &amp;&amp; is_array($p_filelist[0])) {
                $v_att_list = $p_filelist;

            // ----- The list is a list of string names
            } else {
                $v_string_list = $p_filelist;
            }

        // ----- Look if the $p_filelist is a string
        } elseif (is_string($p_filelist)) {
            // ----- Create a list from the string
            $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);

        // ----- Invalid variable type for $p_filelist
        } else {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid variable type p_filelist&quot;);

            return 0;
        }

        // ----- Reformat the string list
        if (sizeof($v_string_list) != 0) {
            foreach ($v_string_list as $v_string) {
                if ($v_string != &apos;&apos;) {
                    $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;
                } else {
                }
            }
        }

        // ----- For each file in the list check the attributes
        $v_supported_attributes = array(
            PCLZIP_ATT_FILE_NAME =&gt; &apos;mandatory&apos;,
            PCLZIP_ATT_FILE_NEW_SHORT_NAME =&gt; &apos;optional&apos;,
            PCLZIP_ATT_FILE_NEW_FULL_NAME =&gt; &apos;optional&apos;,
            PCLZIP_ATT_FILE_MTIME =&gt; &apos;optional&apos;,
            PCLZIP_ATT_FILE_CONTENT =&gt; &apos;optional&apos;,
            PCLZIP_ATT_FILE_COMMENT =&gt; &apos;optional&apos;
        );
        foreach ($v_att_list as $v_entry) {
            $v_result = $this-&gt;privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);
            if ($v_result != 1) {
                return 0;
            }
        }

        // ----- Expand the filelist (expand directories)
        $v_result = $this-&gt;privFileDescrExpand($v_filedescr_list, $v_options);
        if ($v_result != 1) {
            return 0;
        }

        // ----- Call the create fct
        $v_result = $this-&gt;privCreate($v_filedescr_list, $p_result_list, $v_options);
        if ($v_result != 1) {
            return 0;
        }

        // ----- Return
        return $p_result_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function :
    //   add($p_filelist, $p_add_dir=&quot;&quot;, $p_remove_dir=&quot;&quot;)
    //   add($p_filelist, $p_option, $p_option_value, ...)
    // Description :
    //   This method supports two synopsis. The first one is historical.
    //   This methods add the list of files in an existing archive.
    //   If a file with the same name already exists, it is added at the end of the
    //   archive, the first one is still present.
    //   If the archive does not exist, it is created.
    // Parameters :
    //   $p_filelist : An array containing file or directory names, or
    //                 a string containing one filename or one directory name, or
    //                 a string containing a list of filenames and/or directory
    //                 names separated by spaces.
    //   $p_add_dir : A path to add before the real path of the archived file,
    //                in order to have it memorized in the archive.
    //   $p_remove_dir : A path to remove from the real path of the file to archive,
    //                   in order to have a shorter path memorized in the archive.
    //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir
    //                   is removed first, before $p_add_dir is added.
    // Options :
    //   PCLZIP_OPT_ADD_PATH :
    //   PCLZIP_OPT_REMOVE_PATH :
    //   PCLZIP_OPT_REMOVE_ALL_PATH :
    //   PCLZIP_OPT_COMMENT :
    //   PCLZIP_OPT_ADD_COMMENT :
    //   PCLZIP_OPT_PREPEND_COMMENT :
    //   PCLZIP_CB_PRE_ADD :
    //   PCLZIP_CB_POST_ADD :
    // Return Values :
    //   0 on failure,
    //   The list of the added files, with a status of the add action.
    //   (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    public function add($p_filelist)
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Set default values
        $v_options                            = array();
        $v_options[PCLZIP_OPT_NO_COMPRESSION] = false;

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Look for arguments
        if ($v_size &gt; 1) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Remove form the options list the first argument
            array_shift($v_arg_list);
            $v_size--;

            // ----- Look for first arg
            if ((is_integer($v_arg_list[0])) &amp;&amp; ($v_arg_list[0] &gt; 77000)) {

                // ----- Parse the options
                $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, array(
                    PCLZIP_OPT_REMOVE_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_REMOVE_ALL_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_ADD_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_CB_PRE_ADD =&gt; &apos;optional&apos;,
                    PCLZIP_CB_POST_ADD =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_NO_COMPRESSION =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_COMMENT =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_ADD_COMMENT =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_PREPEND_COMMENT =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_THRESHOLD =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_ON =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_OFF =&gt; &apos;optional&apos;
                    //, PCLZIP_OPT_CRYPT =&gt; &apos;optional&apos;
                ));
                if ($v_result != 1) {
                    return 0;
                }

            // ----- Look for 2 args
            // Here we need to support the first historic synopsis of the
            // method.
            } else {

                // ----- Get the first argument
                $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];

                // ----- Look for the optional second argument
                if ($v_size == 2) {
                    $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];
                } elseif ($v_size &gt; 2) {
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid number / type of arguments&quot;);

                    // ----- Return
                    return 0;
                }
            }
        }

        // ----- Look for default option values
        $this-&gt;privOptionDefaultThreshold($v_options);

        // ----- Init
        $v_string_list    = array();
        $v_att_list       = array();
        $v_filedescr_list = array();
        $p_result_list    = array();

        // ----- Look if the $p_filelist is really an array
        if (is_array($p_filelist)) {

            // ----- Look if the first element is also an array
            //       This will mean that this is a file description entry
            if (isset($p_filelist[0]) &amp;&amp; is_array($p_filelist[0])) {
                $v_att_list = $p_filelist;

            // ----- The list is a list of string names
            } else {
                $v_string_list = $p_filelist;
            }

        // ----- Look if the $p_filelist is a string
        } elseif (is_string($p_filelist)) {
            // ----- Create a list from the string
            $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);

        // ----- Invalid variable type for $p_filelist
        } else {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid variable type &apos;&quot; . gettype($p_filelist) . &quot;&apos; for p_filelist&quot;);

            return 0;
        }

        // ----- Reformat the string list
        if (sizeof($v_string_list) != 0) {
            foreach ($v_string_list as $v_string) {
                $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;
            }
        }

        // ----- For each file in the list check the attributes
        $v_supported_attributes = array(
            PCLZIP_ATT_FILE_NAME =&gt; &apos;mandatory&apos;,
            PCLZIP_ATT_FILE_NEW_SHORT_NAME =&gt; &apos;optional&apos;,
            PCLZIP_ATT_FILE_NEW_FULL_NAME =&gt; &apos;optional&apos;,
            PCLZIP_ATT_FILE_MTIME =&gt; &apos;optional&apos;,
            PCLZIP_ATT_FILE_CONTENT =&gt; &apos;optional&apos;,
            PCLZIP_ATT_FILE_COMMENT =&gt; &apos;optional&apos;
        );
        foreach ($v_att_list as $v_entry) {
            $v_result = $this-&gt;privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);
            if ($v_result != 1) {
                return 0;
            }
        }

        // ----- Expand the filelist (expand directories)
        $v_result = $this-&gt;privFileDescrExpand($v_filedescr_list, $v_options);
        if ($v_result != 1) {
            return 0;
        }

        // ----- Call the create fct
        $v_result = $this-&gt;privAdd($v_filedescr_list, $p_result_list, $v_options);
        if ($v_result != 1) {
            return 0;
        }

        // ----- Return
        return $p_result_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : listContent()
    // Description :
    //   This public method, gives the list of the files and directories, with their
    //   properties.
    //   The properties of each entries in the list are (used also in other functions) :
    //     filename : Name of the file. For a create or add action it is the filename
    //                given by the user. For an extract function it is the filename
    //                of the extracted file.
    //     stored_filename : Name of the file / directory stored in the archive.
    //     size : Size of the stored file.
    //     compressed_size : Size of the file&apos;s data compressed in the archive
    //                       (without the headers overhead)
    //     mtime : Last known modification date of the file (UNIX timestamp)
    //     comment : Comment associated with the file
    //     folder : true | false
    //     index : index of the file in the archive
    //     status : status of the action (depending of the action) :
    //              Values are :
    //                ok : OK !
    //                filtered : the file / dir is not extracted (filtered by user)
    //                already_a_directory : the file can not be extracted because a
    //                                      directory with the same name already exists
    //                write_protected : the file can not be extracted because a file
    //                                  with the same name already exists and is
    //                                  write protected
    //                newer_exist : the file was not extracted because a newer file exists
    //                path_creation_fail : the file is not extracted because the folder
    //                                     does not exist and can not be created
    //                write_error : the file was not extracted because there was a
    //                              error while writing the file
    //                read_error : the file was not extracted because there was a error
    //                             while reading the file
    //                invalid_header : the file was not extracted because of an archive
    //                                 format error (bad file header)
    //   Note that each time a method can continue operating when there
    //   is an action error on a file, the error is only logged in the file status.
    // Return Values :
    //   0 on an unrecoverable failure,
    //   The list of the files in the archive.
    // --------------------------------------------------------------------------------
    public function listContent()
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Check archive
        if (!$this-&gt;privCheckFormat()) {
            return (0);
        }

        // ----- Call the extracting fct
        $p_list = array();
        if (($v_result = $this-&gt;privList($p_list)) != 1) {
            unset($p_list);

            return (0);
        }

        // ----- Return
        return $p_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function :
    //   extract($p_path=&quot;./&quot;, $p_remove_path=&quot;&quot;)
    //   extract([$p_option, $p_option_value, ...])
    // Description :
    //   This method supports two synopsis. The first one is historical.
    //   This method extract all the files / directories from the archive to the
    //   folder indicated in $p_path.
    //   If you want to ignore the &apos;root&apos; part of path of the memorized files
    //   you can indicate this in the optional $p_remove_path parameter.
    //   By default, if a newer file with the same name already exists, the
    //   file is not extracted.
    //
    //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions
    //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append
    //   at the end of the path value of PCLZIP_OPT_PATH.
    // Parameters :
    //   $p_path : Path where the files and directories are to be extracted
    //   $p_remove_path : First part (&apos;root&apos; part) of the memorized path
    //                    (if any similar) to remove while extracting.
    // Options :
    //   PCLZIP_OPT_PATH :
    //   PCLZIP_OPT_ADD_PATH :
    //   PCLZIP_OPT_REMOVE_PATH :
    //   PCLZIP_OPT_REMOVE_ALL_PATH :
    //   PCLZIP_CB_PRE_EXTRACT :
    //   PCLZIP_CB_POST_EXTRACT :
    // Return Values :
    //   0 or a negative value on failure,
    //   The list of the extracted files, with a status of the action.
    //   (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    public function extract()
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Check archive
        if (!$this-&gt;privCheckFormat()) {
            return (0);
        }

        // ----- Set default values
        $v_options         = array();
        //    $v_path = &quot;./&quot;;
        $v_path            = &apos;&apos;;
        $v_remove_path     = &quot;&quot;;
        $v_remove_all_path = false;

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Default values for option
        $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = false;

        // ----- Look for arguments
        if ($v_size &gt; 0) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Look for first arg
            if ((is_integer($v_arg_list[0])) &amp;&amp; ($v_arg_list[0] &gt; 77000)) {

                // ----- Parse the options
                $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, array(
                    PCLZIP_OPT_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_REMOVE_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_REMOVE_ALL_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_ADD_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_CB_PRE_EXTRACT =&gt; &apos;optional&apos;,
                    PCLZIP_CB_POST_EXTRACT =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_SET_CHMOD =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_BY_NAME =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_BY_EREG =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_BY_PREG =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_BY_INDEX =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_EXTRACT_AS_STRING =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_EXTRACT_IN_OUTPUT =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_REPLACE_NEWER =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_STOP_ON_ERROR =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_EXTRACT_DIR_RESTRICTION =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_THRESHOLD =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_ON =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_OFF =&gt; &apos;optional&apos;
                ));
                if ($v_result != 1) {
                    return 0;
                }

                // ----- Set the arguments
                if (isset($v_options[PCLZIP_OPT_PATH])) {
                    $v_path = $v_options[PCLZIP_OPT_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {
                    $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {
                    $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {
                    // ----- Check for &apos;/&apos; in last path char
                    if ((strlen($v_path) &gt; 0) &amp;&amp; (substr($v_path, -1) != &apos;/&apos;)) {
                        $v_path .= &apos;/&apos;;
                    }
                    $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];
                }

            // ----- Look for 2 args
            // Here we need to support the first historic synopsis of the
            // method.
            } else {

                // ----- Get the first argument
                $v_path = $v_arg_list[0];

                // ----- Look for the optional second argument
                if ($v_size == 2) {
                    $v_remove_path = $v_arg_list[1];
                } elseif ($v_size &gt; 2) {
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid number / type of arguments&quot;);

                    // ----- Return
                    return 0;
                }
            }
        }

        // ----- Look for default option values
        $this-&gt;privOptionDefaultThreshold($v_options);

        // ----- Trace

        // ----- Call the extracting fct
        $p_list   = array();
        $v_result = $this-&gt;privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options);
        if ($v_result &lt; 1) {
            unset($p_list);

            return (0);
        }

        // ----- Return
        return $p_list;
    }
    // --------------------------------------------------------------------------------


    // --------------------------------------------------------------------------------
    // Function :
    //   extractByIndex($p_index, $p_path=&quot;./&quot;, $p_remove_path=&quot;&quot;)
    //   extractByIndex($p_index, [$p_option, $p_option_value, ...])
    // Description :
    //   This method supports two synopsis. The first one is historical.
    //   This method is doing a partial extract of the archive.
    //   The extracted files or folders are identified by their index in the
    //   archive (from 0 to n).
    //   Note that if the index identify a folder, only the folder entry is
    //   extracted, not all the files included in the archive.
    // Parameters :
    //   $p_index : A single index (integer) or a string of indexes of files to
    //              extract. The form of the string is &quot;0,4-6,8-12&quot; with only numbers
    //              and &apos;-&apos; for range or &apos;,&apos; to separate ranges. No spaces or &apos;;&apos;
    //              are allowed.
    //   $p_path : Path where the files and directories are to be extracted
    //   $p_remove_path : First part (&apos;root&apos; part) of the memorized path
    //                    (if any similar) to remove while extracting.
    // Options :
    //   PCLZIP_OPT_PATH :
    //   PCLZIP_OPT_ADD_PATH :
    //   PCLZIP_OPT_REMOVE_PATH :
    //   PCLZIP_OPT_REMOVE_ALL_PATH :
    //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and
    //     not as files.
    //     The resulting content is in a new field &apos;content&apos; in the file
    //     structure.
    //     This option must be used alone (any other options are ignored).
    //   PCLZIP_CB_PRE_EXTRACT :
    //   PCLZIP_CB_POST_EXTRACT :
    // Return Values :
    //   0 on failure,
    //   The list of the extracted files, with a status of the action.
    //   (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    //function extractByIndex($p_index, options...)
    public function extractByIndex($p_index)
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Check archive
        if (!$this-&gt;privCheckFormat()) {
            return (0);
        }

        // ----- Set default values
        $v_options         = array();
        //    $v_path = &quot;./&quot;;
        $v_path            = &apos;&apos;;
        $v_remove_path     = &quot;&quot;;
        $v_remove_all_path = false;

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Default values for option
        $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = false;

        // ----- Look for arguments
        if ($v_size &gt; 1) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Remove form the options list the first argument
            array_shift($v_arg_list);
            $v_size--;

            // ----- Look for first arg
            if ((is_integer($v_arg_list[0])) &amp;&amp; ($v_arg_list[0] &gt; 77000)) {

                // ----- Parse the options
                $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, array(
                    PCLZIP_OPT_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_REMOVE_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_REMOVE_ALL_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_EXTRACT_AS_STRING =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_ADD_PATH =&gt; &apos;optional&apos;,
                    PCLZIP_CB_PRE_EXTRACT =&gt; &apos;optional&apos;,
                    PCLZIP_CB_POST_EXTRACT =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_SET_CHMOD =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_REPLACE_NEWER =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_STOP_ON_ERROR =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_EXTRACT_DIR_RESTRICTION =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_THRESHOLD =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_ON =&gt; &apos;optional&apos;,
                    PCLZIP_OPT_TEMP_FILE_OFF =&gt; &apos;optional&apos;
                ));
                if ($v_result != 1) {
                    return 0;
                }

                // ----- Set the arguments
                if (isset($v_options[PCLZIP_OPT_PATH])) {
                    $v_path = $v_options[PCLZIP_OPT_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {
                    $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {
                    $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];
                }
                if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {
                    // ----- Check for &apos;/&apos; in last path char
                    if ((strlen($v_path) &gt; 0) &amp;&amp; (substr($v_path, -1) != &apos;/&apos;)) {
                        $v_path .= &apos;/&apos;;
                    }
                    $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];
                }
                if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {
                    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = false;
                } else {
                }

            // ----- Look for 2 args
            // Here we need to support the first historic synopsis of the
            // method.
            } else {

                // ----- Get the first argument
                $v_path = $v_arg_list[0];

                // ----- Look for the optional second argument
                if ($v_size == 2) {
                    $v_remove_path = $v_arg_list[1];
                } elseif ($v_size &gt; 2) {
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid number / type of arguments&quot;);

                    // ----- Return
                    return 0;
                }
            }
        }

        // ----- Trace

        // ----- Trick
        // Here I want to reuse extractByRule(), so I need to parse the $p_index
        // with privParseOptions()
        $v_arg_trick     = array(
            PCLZIP_OPT_BY_INDEX,
            $p_index
        );
        $v_options_trick = array();
        $v_result        = $this-&gt;privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick, array(
            PCLZIP_OPT_BY_INDEX =&gt; &apos;optional&apos;
        ));
        if ($v_result != 1) {
            return 0;
        }
        $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];

        // ----- Look for default option values
        $this-&gt;privOptionDefaultThreshold($v_options);

        // ----- Call the extracting fct
        if (($v_result = $this-&gt;privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) &lt; 1) {
            return (0);
        }

        // ----- Return
        return $p_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function :
    //   delete([$p_option, $p_option_value, ...])
    // Description :
    //   This method removes files from the archive.
    //   If no parameters are given, then all the archive is emptied.
    // Parameters :
    //   None or optional arguments.
    // Options :
    //   PCLZIP_OPT_BY_INDEX :
    //   PCLZIP_OPT_BY_NAME :
    //   PCLZIP_OPT_BY_EREG :
    //   PCLZIP_OPT_BY_PREG :
    // Return Values :
    //   0 on failure,
    //   The list of the files which are still present in the archive.
    //   (see PclZip::listContent() for list entry format)
    // --------------------------------------------------------------------------------
    public function delete()
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Check archive
        if (!$this-&gt;privCheckFormat()) {
            return (0);
        }

        // ----- Set default values
        $v_options = array();

        // ----- Look for variable options arguments
        $v_size = func_num_args();

        // ----- Look for arguments
        if ($v_size &gt; 0) {
            // ----- Get the arguments
            $v_arg_list = func_get_args();

            // ----- Parse the options
            $v_result = $this-&gt;privParseOptions($v_arg_list, $v_size, $v_options, array(
                PCLZIP_OPT_BY_NAME =&gt; &apos;optional&apos;,
                PCLZIP_OPT_BY_EREG =&gt; &apos;optional&apos;,
                PCLZIP_OPT_BY_PREG =&gt; &apos;optional&apos;,
                PCLZIP_OPT_BY_INDEX =&gt; &apos;optional&apos;
            ));
            if ($v_result != 1) {
                return 0;
            }
        }

        // ----- Magic quotes trick
        $this-&gt;privDisableMagicQuotes();

        // ----- Call the delete fct
        $v_list = array();
        if (($v_result = $this-&gt;privDeleteByRule($v_list, $v_options)) != 1) {
            $this-&gt;privSwapBackMagicQuotes();
            unset($v_list);

            return (0);
        }

        // ----- Magic quotes trick
        $this-&gt;privSwapBackMagicQuotes();

        // ----- Return
        return $v_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : deleteByIndex()
    // Description :
    //   ***** Deprecated *****
    //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.
    // --------------------------------------------------------------------------------
    public function deleteByIndex($p_index)
    {

        $p_list = $this-&gt;delete(PCLZIP_OPT_BY_INDEX, $p_index);

        // ----- Return
        return $p_list;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : properties()
    // Description :
    //   This method gives the properties of the archive.
    //   The properties are :
    //     nb : Number of files in the archive
    //     comment : Comment associated with the archive file
    //     status : not_exist, ok
    // Parameters :
    //   None
    // Return Values :
    //   0 on failure,
    //   An array with the archive properties.
    // --------------------------------------------------------------------------------
    public function properties()
    {

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Magic quotes trick
        $this-&gt;privDisableMagicQuotes();

        // ----- Check archive
        if (!$this-&gt;privCheckFormat()) {
            $this-&gt;privSwapBackMagicQuotes();

            return (0);
        }

        // ----- Default properties
        $v_prop            = array();
        $v_prop[&apos;comment&apos;] = &apos;&apos;;
        $v_prop[&apos;nb&apos;]      = 0;
        $v_prop[&apos;status&apos;]  = &apos;not_exist&apos;;

        // ----- Look if file exists
        if (@is_file($this-&gt;zipname)) {
            // ----- Open the zip file
            if (($this-&gt;zip_fd = @fopen($this-&gt;zipname, &apos;rb&apos;)) == 0) {
                $this-&gt;privSwapBackMagicQuotes();

                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open archive \&apos;&apos; . $this-&gt;zipname . &apos;\&apos; in binary read mode&apos;);

                // ----- Return
                return 0;
            }

            // ----- Read the central directory informations
            $v_central_dir = array();
            if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1) {
                $this-&gt;privSwapBackMagicQuotes();

                return 0;
            }

            // ----- Close the zip file
            $this-&gt;privCloseFd();

            // ----- Set the user attributes
            $v_prop[&apos;comment&apos;] = $v_central_dir[&apos;comment&apos;];
            $v_prop[&apos;nb&apos;]      = $v_central_dir[&apos;entries&apos;];
            $v_prop[&apos;status&apos;]  = &apos;ok&apos;;
        }

        // ----- Magic quotes trick
        $this-&gt;privSwapBackMagicQuotes();

        // ----- Return
        return $v_prop;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : duplicate()
    // Description :
    //   This method creates an archive by copying the content of an other one. If
    //   the archive already exist, it is replaced by the new one without any warning.
    // Parameters :
    //   $p_archive : The filename of a valid archive, or
    //                a valid PclZip object.
    // Return Values :
    //   1 on success.
    //   0 or a negative value on error (error code).
    // --------------------------------------------------------------------------------
    public function duplicate($p_archive)
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Look if the $p_archive is a PclZip object
        if ((is_object($p_archive)) &amp;&amp; (get_class($p_archive) == &apos;pclzip&apos;)) {

            // ----- Duplicate the archive
            $v_result = $this-&gt;privDuplicate($p_archive-&gt;zipname);

        // ----- Look if the $p_archive is a string (so a filename)
        } elseif (is_string($p_archive)) {

            // ----- Check that $p_archive is a valid zip file
            // TBC : Should also check the archive format
            if (!is_file($p_archive)) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, &quot;No file with filename &apos;&quot; . $p_archive . &quot;&apos;&quot;);
                $v_result = PCLZIP_ERR_MISSING_FILE;
            } else {
                // ----- Duplicate the archive
                $v_result = $this-&gt;privDuplicate($p_archive);
            }

        // ----- Invalid variable
        } else {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid variable type p_archive_to_add&quot;);
            $v_result = PCLZIP_ERR_INVALID_PARAMETER;
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : merge()
    // Description :
    //   This method merge the $p_archive_to_add archive at the end of the current
    //   one ($this).
    //   If the archive ($this) does not exist, the merge becomes a duplicate.
    //   If the $p_archive_to_add archive does not exist, the merge is a success.
    // Parameters :
    //   $p_archive_to_add : It can be directly the filename of a valid zip archive,
    //                       or a PclZip object archive.
    // Return Values :
    //   1 on success,
    //   0 or negative values on error (see below).
    // --------------------------------------------------------------------------------
    public function merge($p_archive_to_add)
    {
        $v_result = 1;

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Check archive
        if (!$this-&gt;privCheckFormat()) {
            return (0);
        }

        // ----- Look if the $p_archive_to_add is a PclZip object
        if ((is_object($p_archive_to_add)) &amp;&amp; (get_class($p_archive_to_add) == &apos;pclzip&apos;)) {

            // ----- Merge the archive
            $v_result = $this-&gt;privMerge($p_archive_to_add);

        // ----- Look if the $p_archive_to_add is a string (so a filename)
        } elseif (is_string($p_archive_to_add)) {

            // ----- Create a temporary archive
            $v_object_archive = new PclZip($p_archive_to_add);

            // ----- Merge the archive
            $v_result = $this-&gt;privMerge($v_object_archive);

        // ----- Invalid variable
        } else {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid variable type p_archive_to_add&quot;);
            $v_result = PCLZIP_ERR_INVALID_PARAMETER;
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : errorCode()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function errorCode()
    {
        if (PCLZIP_ERROR_EXTERNAL == 1) {
            return (PclErrorCode());
        } else {
            return ($this-&gt;error_code);
        }
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : errorName()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function errorName($p_with_code = false)
    {
        $v_name = array(
            PCLZIP_ERR_NO_ERROR =&gt; &apos;PCLZIP_ERR_NO_ERROR&apos;,
            PCLZIP_ERR_WRITE_OPEN_FAIL =&gt; &apos;PCLZIP_ERR_WRITE_OPEN_FAIL&apos;,
            PCLZIP_ERR_READ_OPEN_FAIL =&gt; &apos;PCLZIP_ERR_READ_OPEN_FAIL&apos;,
            PCLZIP_ERR_INVALID_PARAMETER =&gt; &apos;PCLZIP_ERR_INVALID_PARAMETER&apos;,
            PCLZIP_ERR_MISSING_FILE =&gt; &apos;PCLZIP_ERR_MISSING_FILE&apos;,
            PCLZIP_ERR_FILENAME_TOO_LONG =&gt; &apos;PCLZIP_ERR_FILENAME_TOO_LONG&apos;,
            PCLZIP_ERR_INVALID_ZIP =&gt; &apos;PCLZIP_ERR_INVALID_ZIP&apos;,
            PCLZIP_ERR_BAD_EXTRACTED_FILE =&gt; &apos;PCLZIP_ERR_BAD_EXTRACTED_FILE&apos;,
            PCLZIP_ERR_DIR_CREATE_FAIL =&gt; &apos;PCLZIP_ERR_DIR_CREATE_FAIL&apos;,
            PCLZIP_ERR_BAD_EXTENSION =&gt; &apos;PCLZIP_ERR_BAD_EXTENSION&apos;,
            PCLZIP_ERR_BAD_FORMAT =&gt; &apos;PCLZIP_ERR_BAD_FORMAT&apos;,
            PCLZIP_ERR_DELETE_FILE_FAIL =&gt; &apos;PCLZIP_ERR_DELETE_FILE_FAIL&apos;,
            PCLZIP_ERR_RENAME_FILE_FAIL =&gt; &apos;PCLZIP_ERR_RENAME_FILE_FAIL&apos;,
            PCLZIP_ERR_BAD_CHECKSUM =&gt; &apos;PCLZIP_ERR_BAD_CHECKSUM&apos;,
            PCLZIP_ERR_INVALID_ARCHIVE_ZIP =&gt; &apos;PCLZIP_ERR_INVALID_ARCHIVE_ZIP&apos;,
            PCLZIP_ERR_MISSING_OPTION_VALUE =&gt; &apos;PCLZIP_ERR_MISSING_OPTION_VALUE&apos;,
            PCLZIP_ERR_INVALID_OPTION_VALUE =&gt; &apos;PCLZIP_ERR_INVALID_OPTION_VALUE&apos;,
            PCLZIP_ERR_UNSUPPORTED_COMPRESSION =&gt; &apos;PCLZIP_ERR_UNSUPPORTED_COMPRESSION&apos;,
            PCLZIP_ERR_UNSUPPORTED_ENCRYPTION =&gt; &apos;PCLZIP_ERR_UNSUPPORTED_ENCRYPTION&apos;,
            PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE =&gt; &apos;PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE&apos;,
            PCLZIP_ERR_DIRECTORY_RESTRICTION =&gt; &apos;PCLZIP_ERR_DIRECTORY_RESTRICTION&apos;
        );

        if (isset($v_name[$this-&gt;error_code])) {
            $v_value = $v_name[$this-&gt;error_code];
        } else {
            $v_value = &apos;NoName&apos;;
        }

        if ($p_with_code) {
            return ($v_value . &apos; (&apos; . $this-&gt;error_code . &apos;)&apos;);
        } else {
            return ($v_value);
        }
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : errorInfo()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function errorInfo($p_full = false)
    {
        if (PCLZIP_ERROR_EXTERNAL == 1) {
            return (PclErrorString());
        } else {
            if ($p_full) {
                return ($this-&gt;errorName(true) . &quot; : &quot; . $this-&gt;error_string);
            } else {
                return ($this-&gt;error_string . &quot; [code &quot; . $this-&gt;error_code . &quot;]&quot;);
            }
        }
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****
    // *****                                                        *****
    // *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privCheckFormat()
    // Description :
    //   This method check that the archive exists and is a valid zip archive.
    //   Several level of check exists. (futur)
    // Parameters :
    //   $p_level : Level of check. Default 0.
    //              0 : Check the first bytes (magic codes) (default value))
    //              1 : 0 + Check the central directory (futur)
    //              2 : 1 + Check each file header (futur)
    // Return Values :
    //   true on success,
    //   false on error, the error code is set.
    // --------------------------------------------------------------------------------
    public function privCheckFormat($p_level = 0)
    {
        $v_result = true;

        // ----- Reset the file system cache
        clearstatcache();

        // ----- Reset the error handler
        $this-&gt;privErrorReset();

        // ----- Look if the file exits
        if (!is_file($this-&gt;zipname)) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, &quot;Missing archive file &apos;&quot; . $this-&gt;zipname . &quot;&apos;&quot;);

            return (false);
        }

        // ----- Check that the file is readeable
        if (!is_readable($this-&gt;zipname)) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &quot;Unable to read archive &apos;&quot; . $this-&gt;zipname . &quot;&apos;&quot;);

            return (false);
        }

        // ----- Check the magic code
        // TBC

        // ----- Check the central header
        // TBC

        // ----- Check each file header
        // TBC

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privParseOptions()
    // Description :
    //   This internal methods reads the variable list of arguments ($p_options_list,
    //   $p_size) and generate an array with the options and values ($v_result_list).
    //   $v_requested_options contains the options that can be present and those that
    //   must be present.
    //   $v_requested_options is an array, with the option value as key, and &apos;optional&apos;,
    //   or &apos;mandatory&apos; as value.
    // Parameters :
    //   See above.
    // Return Values :
    //   1 on success.
    //   0 on failure.
    // --------------------------------------------------------------------------------
    public function privParseOptions(&amp;$p_options_list, $p_size, &amp;$v_result_list, $v_requested_options = false)
    {
        $v_result = 1;

        // ----- Read the options
        $i = 0;
        while ($i &lt; $p_size) {

            // ----- Check if the option is supported
            if (!isset($v_requested_options[$p_options_list[$i]])) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid optional parameter &apos;&quot; . $p_options_list[$i] . &quot;&apos; for this method&quot;);

                // ----- Return
                return PclZip::errorCode();
            }

            // ----- Look for next option
            switch ($p_options_list[$i]) {
                // ----- Look for options that request a path value
                case PCLZIP_OPT_PATH:
                case PCLZIP_OPT_REMOVE_PATH:
                case PCLZIP_OPT_ADD_PATH:
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i + 1], false);
                    $i++;
                    break;

                case PCLZIP_OPT_TEMP_FILE_THRESHOLD:
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    // ----- Check for incompatible options
                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos; can not be used with option &apos;PCLZIP_OPT_TEMP_FILE_OFF&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    // ----- Check the value
                    $v_value = $p_options_list[$i + 1];
                    if ((!is_integer($v_value)) || ($v_value &lt; 0)) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Integer expected for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    // ----- Get the value (and convert it in bytes)
                    $v_result_list[$p_options_list[$i]] = $v_value * 1048576;
                    $i++;
                    break;

                case PCLZIP_OPT_TEMP_FILE_ON:
                    // ----- Check for incompatible options
                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos; can not be used with option &apos;PCLZIP_OPT_TEMP_FILE_OFF&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    $v_result_list[$p_options_list[$i]] = true;
                    break;

                case PCLZIP_OPT_TEMP_FILE_OFF:
                    // ----- Check for incompatible options
                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos; can not be used with option &apos;PCLZIP_OPT_TEMP_FILE_ON&apos;&quot;);

                        return PclZip::errorCode();
                    }
                    // ----- Check for incompatible options
                    if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos; can not be used with option &apos;PCLZIP_OPT_TEMP_FILE_THRESHOLD&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    $v_result_list[$p_options_list[$i]] = true;
                    break;

                case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION:
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    if (is_string($p_options_list[$i + 1]) &amp;&amp; ($p_options_list[$i + 1] != &apos;&apos;)) {
                        $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i + 1], false);
                        $i++;
                    } else {
                    }
                    break;

                // ----- Look for options that request an array of string for value
                case PCLZIP_OPT_BY_NAME:
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    if (is_string($p_options_list[$i + 1])) {
                        $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i + 1];
                    } elseif (is_array($p_options_list[$i + 1])) {
                        $v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];
                    } else {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Wrong parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }
                    $i++;
                    break;

                // ----- Look for options that request an EREG or PREG expression
                case PCLZIP_OPT_BY_EREG:
                    $p_options_list[$i] = PCLZIP_OPT_BY_PREG;
                    // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG
                    // to PCLZIP_OPT_BY_PREG
                case PCLZIP_OPT_BY_PREG:
                    //case PCLZIP_OPT_CRYPT :
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    if (is_string($p_options_list[$i + 1])) {
                        $v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];
                    } else {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Wrong parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }
                    $i++;
                    break;

                // ----- Look for options that takes a string
                case PCLZIP_OPT_COMMENT:
                case PCLZIP_OPT_ADD_COMMENT:
                case PCLZIP_OPT_PREPEND_COMMENT:
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    if (is_string($p_options_list[$i + 1])) {
                        $v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];
                    } else {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Wrong parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }
                    $i++;
                    break;

                // ----- Look for options that request an array of index
                case PCLZIP_OPT_BY_INDEX:
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    $v_work_list = array();
                    if (is_string($p_options_list[$i + 1])) {

                        // ----- Remove spaces
                        $p_options_list[$i + 1] = strtr($p_options_list[$i + 1], &apos; &apos;, &apos;&apos;);

                        // ----- Parse items
                        $v_work_list = explode(&quot;,&quot;, $p_options_list[$i + 1]);
                    } elseif (is_integer($p_options_list[$i + 1])) {
                        $v_work_list[0] = $p_options_list[$i + 1] . &apos;-&apos; . $p_options_list[$i + 1];
                    } elseif (is_array($p_options_list[$i + 1])) {
                        $v_work_list = $p_options_list[$i + 1];
                    } else {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Value must be integer, string or array for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Reduce the index list
                    // each index item in the list must be a couple with a start and
                    // an end value : [0,3], [5-5], [8-10], ...
                    // ----- Check the format of each item
                    $v_sort_flag  = false;
                    $v_sort_value = 0;
                    for ($j = 0; $j &lt; sizeof($v_work_list); $j++) {
                        // ----- Explode the item
                        $v_item_list      = explode(&quot;-&quot;, $v_work_list[$j]);
                        $v_size_item_list = sizeof($v_item_list);

                        // ----- TBC : Here we might check that each item is a
                        // real integer ...

                        // ----- Look for single value
                        if ($v_size_item_list == 1) {
                            // ----- Set the option value
                            $v_result_list[$p_options_list[$i]][$j][&apos;start&apos;] = $v_item_list[0];
                            $v_result_list[$p_options_list[$i]][$j][&apos;end&apos;]   = $v_item_list[0];
                        } elseif ($v_size_item_list == 2) {
                            // ----- Set the option value
                            $v_result_list[$p_options_list[$i]][$j][&apos;start&apos;] = $v_item_list[0];
                            $v_result_list[$p_options_list[$i]][$j][&apos;end&apos;]   = $v_item_list[1];
                        } else {
                            // ----- Error log
                            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Too many values in index range for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                            // ----- Return
                            return PclZip::errorCode();
                        }

                        // ----- Look for list sort
                        if ($v_result_list[$p_options_list[$i]][$j][&apos;start&apos;] &lt; $v_sort_value) {
                            $v_sort_flag = true;

                            // ----- TBC : An automatic sort should be writen ...
                            // ----- Error log
                            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Invalid order of index range for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                            // ----- Return
                            return PclZip::errorCode();
                        }
                        $v_sort_value = $v_result_list[$p_options_list[$i]][$j][&apos;start&apos;];
                    }

                    // ----- Sort the items
                    if ($v_sort_flag) {
                        // TBC : To Be Completed
                    }

                    // ----- Next option
                    $i++;
                    break;

                // ----- Look for options that request no value
                case PCLZIP_OPT_REMOVE_ALL_PATH:
                case PCLZIP_OPT_EXTRACT_AS_STRING:
                case PCLZIP_OPT_NO_COMPRESSION:
                case PCLZIP_OPT_EXTRACT_IN_OUTPUT:
                case PCLZIP_OPT_REPLACE_NEWER:
                case PCLZIP_OPT_STOP_ON_ERROR:
                    $v_result_list[$p_options_list[$i]] = true;
                    break;

                // ----- Look for options that request an octal value
                case PCLZIP_OPT_SET_CHMOD:
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    $v_result_list[$p_options_list[$i]] = $p_options_list[$i + 1];
                    $i++;
                    break;

                // ----- Look for options that request a call-back
                case PCLZIP_CB_PRE_EXTRACT:
                case PCLZIP_CB_POST_EXTRACT:
                case PCLZIP_CB_PRE_ADD:
                case PCLZIP_CB_POST_ADD:
                    /* for futur use
                    case PCLZIP_CB_PRE_DELETE :
                    case PCLZIP_CB_POST_DELETE :
                    case PCLZIP_CB_PRE_LIST :
                    case PCLZIP_CB_POST_LIST :
                    */
                    // ----- Check the number of parameters
                    if (($i + 1) &gt;= $p_size) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, &quot;Missing parameter value for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Get the value
                    $v_function_name = $p_options_list[$i + 1];

                    // ----- Check that the value is a valid existing function
                    if (!function_exists($v_function_name)) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, &quot;Function &apos;&quot; . $v_function_name . &quot;()&apos; is not an existing function for option &apos;&quot; . PclZipUtilOptionText($p_options_list[$i]) . &quot;&apos;&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }

                    // ----- Set the attribute
                    $v_result_list[$p_options_list[$i]] = $v_function_name;
                    $i++;
                    break;

                default:
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Unknown parameter &apos;&quot; . $p_options_list[$i] . &quot;&apos;&quot;);

                    // ----- Return
                    return PclZip::errorCode();
            }

            // ----- Next options
            $i++;
        }

        // ----- Look for mandatory options
        if ($v_requested_options !== false) {
            for ($key = reset($v_requested_options); $key = key($v_requested_options); $key = next($v_requested_options)) {
                // ----- Look for mandatory option
                if ($v_requested_options[$key] == &apos;mandatory&apos;) {
                    // ----- Look if present
                    if (!isset($v_result_list[$key])) {
                        // ----- Error log
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Missing mandatory parameter &quot; . PclZipUtilOptionText($key) . &quot;(&quot; . $key . &quot;)&quot;);

                        // ----- Return
                        return PclZip::errorCode();
                    }
                }
            }
        }

        // ----- Look for default values
        if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {

        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privOptionDefaultThreshold()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privOptionDefaultThreshold(&amp;$p_options)
    {
        $v_result = 1;

        if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {
            return $v_result;
        }

        // ----- Get &apos;memory_limit&apos; configuration value
        $v_memory_limit = ini_get(&apos;memory_limit&apos;);
        $v_memory_limit = trim($v_memory_limit);
        $last           = strtolower(substr($v_memory_limit, -1));

        if ($last == &apos;g&apos;) {
            //$v_memory_limit = $v_memory_limit*1024*1024*1024;
            $v_memory_limit = $v_memory_limit * 1073741824;
        }
        if ($last == &apos;m&apos;) {
            //$v_memory_limit = $v_memory_limit*1024*1024;
            $v_memory_limit = $v_memory_limit * 1048576;
        }
        if ($last == &apos;k&apos;) {
            $v_memory_limit = $v_memory_limit * 1024;
        }

        $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor(intval($v_memory_limit) * PCLZIP_TEMPORARY_FILE_RATIO);

        // ----- Sanity check : No threshold if value lower than 1M
        if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] &lt; 1048576) {
            unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privFileDescrParseAtt()
    // Description :
    // Parameters :
    // Return Values :
    //   1 on success.
    //   0 on failure.
    // --------------------------------------------------------------------------------
    public function privFileDescrParseAtt(&amp;$p_file_list, &amp;$p_filedescr, $v_options, $v_requested_options = false)
    {
        $v_result = 1;

        // ----- For each file in the list check the attributes
        foreach ($p_file_list as $v_key =&gt; $v_value) {

            // ----- Check if the option is supported
            if (!isset($v_requested_options[$v_key])) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid file attribute &apos;&quot; . $v_key . &quot;&apos; for this file&quot;);

                // ----- Return
                return PclZip::errorCode();
            }

            // ----- Look for attribute
            switch ($v_key) {
                case PCLZIP_ATT_FILE_NAME:
                    if (!is_string($v_value)) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot; . gettype($v_value) . &quot;. String expected for attribute &apos;&quot; . PclZipUtilOptionText($v_key) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    $p_filedescr[&apos;filename&apos;] = PclZipUtilPathReduction($v_value);

                    if ($p_filedescr[&apos;filename&apos;] == &apos;&apos;) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid empty filename for attribute &apos;&quot; . PclZipUtilOptionText($v_key) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    break;

                case PCLZIP_ATT_FILE_NEW_SHORT_NAME:
                    if (!is_string($v_value)) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot; . gettype($v_value) . &quot;. String expected for attribute &apos;&quot; . PclZipUtilOptionText($v_key) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    $p_filedescr[&apos;new_short_name&apos;] = PclZipUtilPathReduction($v_value);

                    if ($p_filedescr[&apos;new_short_name&apos;] == &apos;&apos;) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid empty short filename for attribute &apos;&quot; . PclZipUtilOptionText($v_key) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }
                    break;

                case PCLZIP_ATT_FILE_NEW_FULL_NAME:
                    if (!is_string($v_value)) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot; . gettype($v_value) . &quot;. String expected for attribute &apos;&quot; . PclZipUtilOptionText($v_key) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    $p_filedescr[&apos;new_full_name&apos;] = PclZipUtilPathReduction($v_value);

                    if ($p_filedescr[&apos;new_full_name&apos;] == &apos;&apos;) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid empty full filename for attribute &apos;&quot; . PclZipUtilOptionText($v_key) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }
                    break;

                // ----- Look for options that takes a string
                case PCLZIP_ATT_FILE_COMMENT:
                    if (!is_string($v_value)) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot; . gettype($v_value) . &quot;. String expected for attribute &apos;&quot; . PclZipUtilOptionText($v_key) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    $p_filedescr[&apos;comment&apos;] = $v_value;
                    break;

                case PCLZIP_ATT_FILE_MTIME:
                    if (!is_integer($v_value)) {
                        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, &quot;Invalid type &quot; . gettype($v_value) . &quot;. Integer expected for attribute &apos;&quot; . PclZipUtilOptionText($v_key) . &quot;&apos;&quot;);

                        return PclZip::errorCode();
                    }

                    $p_filedescr[&apos;mtime&apos;] = $v_value;
                    break;

                case PCLZIP_ATT_FILE_CONTENT:
                    $p_filedescr[&apos;content&apos;] = $v_value;
                    break;

                default:
                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Unknown parameter &apos;&quot; . $v_key . &quot;&apos;&quot;);

                    // ----- Return
                    return PclZip::errorCode();
            }

            // ----- Look for mandatory options
            if ($v_requested_options !== false) {
                for ($key = reset($v_requested_options); $key = key($v_requested_options); $key = next($v_requested_options)) {
                    // ----- Look for mandatory option
                    if ($v_requested_options[$key] == &apos;mandatory&apos;) {
                        // ----- Look if present
                        if (!isset($p_file_list[$key])) {
                            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Missing mandatory parameter &quot; . PclZipUtilOptionText($key) . &quot;(&quot; . $key . &quot;)&quot;);

                            return PclZip::errorCode();
                        }
                    }
                }
            }

            // end foreach
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privFileDescrExpand()
    // Description :
    //   This method look for each item of the list to see if its a file, a folder
    //   or a string to be added as file. For any other type of files (link, other)
    //   just ignore the item.
    //   Then prepare the information that will be stored for that file.
    //   When its a folder, expand the folder with all the files that are in that
    //   folder (recursively).
    // Parameters :
    // Return Values :
    //   1 on success.
    //   0 on failure.
    // --------------------------------------------------------------------------------
    public function privFileDescrExpand(&amp;$p_filedescr_list, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Create a result list
        $v_result_list = array();

        // ----- Look each entry
        for ($i = 0; $i &lt; sizeof($p_filedescr_list); $i++) {

            // ----- Get filedescr
            $v_descr = $p_filedescr_list[$i];

            // ----- Reduce the filename
            $v_descr[&apos;filename&apos;] = PclZipUtilTranslateWinPath($v_descr[&apos;filename&apos;], false);
            $v_descr[&apos;filename&apos;] = PclZipUtilPathReduction($v_descr[&apos;filename&apos;]);

            // ----- Look for real file or folder
            if (file_exists($v_descr[&apos;filename&apos;])) {
                if (@is_file($v_descr[&apos;filename&apos;])) {
                    $v_descr[&apos;type&apos;] = &apos;file&apos;;
                } elseif (@is_dir($v_descr[&apos;filename&apos;])) {
                    $v_descr[&apos;type&apos;] = &apos;folder&apos;;
                } elseif (@is_link($v_descr[&apos;filename&apos;])) {
                    // skip
                    continue;
                } else {
                    // skip
                    continue;
                }

            // ----- Look for string added as file
            } elseif (isset($v_descr[&apos;content&apos;])) {
                $v_descr[&apos;type&apos;] = &apos;virtual_file&apos;;

            // ----- Missing file
            } else {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, &quot;File &apos;&quot; . $v_descr[&apos;filename&apos;] . &quot;&apos; does not exist&quot;);

                // ----- Return
                return PclZip::errorCode();
            }

            // ----- Calculate the stored filename
            $this-&gt;privCalculateStoredFilename($v_descr, $p_options);

            // ----- Add the descriptor in result list
            $v_result_list[sizeof($v_result_list)] = $v_descr;

            // ----- Look for folder
            if ($v_descr[&apos;type&apos;] == &apos;folder&apos;) {
                // ----- List of items in folder
                $v_dirlist_descr = array();
                $v_dirlist_nb    = 0;
                if ($v_folder_handler = @opendir($v_descr[&apos;filename&apos;])) {
                    while (($v_item_handler = @readdir($v_folder_handler)) !== false) {

                        // ----- Skip &apos;.&apos; and &apos;..&apos;
                        if (($v_item_handler == &apos;.&apos;) || ($v_item_handler == &apos;..&apos;)) {
                            continue;
                        }

                        // ----- Compose the full filename
                        $v_dirlist_descr[$v_dirlist_nb][&apos;filename&apos;] = $v_descr[&apos;filename&apos;] . &apos;/&apos; . $v_item_handler;

                        // ----- Look for different stored filename
                        // Because the name of the folder was changed, the name of the
                        // files/sub-folders also change
                        if (($v_descr[&apos;stored_filename&apos;] != $v_descr[&apos;filename&apos;]) &amp;&amp; (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {
                            if ($v_descr[&apos;stored_filename&apos;] != &apos;&apos;) {
                                $v_dirlist_descr[$v_dirlist_nb][&apos;new_full_name&apos;] = $v_descr[&apos;stored_filename&apos;] . &apos;/&apos; . $v_item_handler;
                            } else {
                                $v_dirlist_descr[$v_dirlist_nb][&apos;new_full_name&apos;] = $v_item_handler;
                            }
                        }

                        $v_dirlist_nb++;
                    }

                    @closedir($v_folder_handler);
                } else {
                    // TBC : unable to open folder in read mode
                }

                // ----- Expand each element of the list
                if ($v_dirlist_nb != 0) {
                    // ----- Expand
                    if (($v_result = $this-&gt;privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {
                        return $v_result;
                    }

                    // ----- Concat the resulting list
                    $v_result_list = array_merge($v_result_list, $v_dirlist_descr);
                } else {
                }

                // ----- Free local array
                unset($v_dirlist_descr);
            }
        }

        // ----- Get the result list
        $p_filedescr_list = $v_result_list;

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privCreate()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privCreate($p_filedescr_list, &amp;$p_result_list, &amp;$p_options)
    {
        $v_result      = 1;
        $v_list_detail = array();

        // ----- Magic quotes trick
        $this-&gt;privDisableMagicQuotes();

        // ----- Open the file in write mode
        if (($v_result = $this-&gt;privOpenFd(&apos;wb&apos;)) != 1) {
            // ----- Return
            return $v_result;
        }

        // ----- Add the list of files
        $v_result = $this-&gt;privAddList($p_filedescr_list, $p_result_list, $p_options);

        // ----- Close
        $this-&gt;privCloseFd();

        // ----- Magic quotes trick
        $this-&gt;privSwapBackMagicQuotes();

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privAdd()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privAdd($p_filedescr_list, &amp;$p_result_list, &amp;$p_options)
    {
        $v_result      = 1;
        $v_list_detail = array();

        // ----- Look if the archive exists or is empty
        if ((!is_file($this-&gt;zipname)) || (filesize($this-&gt;zipname) == 0)) {

            // ----- Do a create
            $v_result = $this-&gt;privCreate($p_filedescr_list, $p_result_list, $p_options);

            // ----- Return
            return $v_result;
        }
        // ----- Magic quotes trick
        $this-&gt;privDisableMagicQuotes();

        // ----- Open the zip file
        if (($v_result = $this-&gt;privOpenFd(&apos;rb&apos;)) != 1) {
            // ----- Magic quotes trick
            $this-&gt;privSwapBackMagicQuotes();

            // ----- Return
            return $v_result;
        }

        // ----- Read the central directory informations
        $v_central_dir = array();
        if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1) {
            $this-&gt;privCloseFd();
            $this-&gt;privSwapBackMagicQuotes();

            return $v_result;
        }

        // ----- Go to beginning of File
        @rewind($this-&gt;zip_fd);

        // ----- Creates a temporay file
        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid(&apos;pclzip-&apos;) . &apos;.tmp&apos;;

        // ----- Open the temporary file in write mode
        if (($v_zip_temp_fd = @fopen($v_zip_temp_name, &apos;wb&apos;)) == 0) {
            $this-&gt;privCloseFd();
            $this-&gt;privSwapBackMagicQuotes();

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open temporary file \&apos;&apos; . $v_zip_temp_name . &apos;\&apos; in binary write mode&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Copy the files from the archive to the temporary file
        // TBC : Here I should better append the file and go back to erase the central dir
        $v_size = $v_central_dir[&apos;offset&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = fread($this-&gt;zip_fd, $v_read_size);
            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Swap the file descriptor
        // Here is a trick : I swap the temporary fd with the zip fd, in order to use
        // the following methods on the temporary fil and not the real archive
        $v_swap        = $this-&gt;zip_fd;
        $this-&gt;zip_fd  = $v_zip_temp_fd;
        $v_zip_temp_fd = $v_swap;

        // ----- Add the files
        $v_header_list = array();
        if (($v_result = $this-&gt;privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1) {
            fclose($v_zip_temp_fd);
            $this-&gt;privCloseFd();
            @unlink($v_zip_temp_name);
            $this-&gt;privSwapBackMagicQuotes();

            // ----- Return
            return $v_result;
        }

        // ----- Store the offset of the central dir
        $v_offset = @ftell($this-&gt;zip_fd);

        // ----- Copy the block of file headers from the old archive
        $v_size = $v_central_dir[&apos;size&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @fread($v_zip_temp_fd, $v_read_size);
            @fwrite($this-&gt;zip_fd, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Create the Central Dir files header
        for ($i = 0, $v_count = 0; $i &lt; sizeof($v_header_list); $i++) {
            // ----- Create the file header
            if ($v_header_list[$i][&apos;status&apos;] == &apos;ok&apos;) {
                if (($v_result = $this-&gt;privWriteCentralFileHeader($v_header_list[$i])) != 1) {
                    fclose($v_zip_temp_fd);
                    $this-&gt;privCloseFd();
                    @unlink($v_zip_temp_name);
                    $this-&gt;privSwapBackMagicQuotes();

                    // ----- Return
                    return $v_result;
                }
                $v_count++;
            }

            // ----- Transform the header to a &apos;usable&apos; info
            $this-&gt;privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);
        }

        // ----- Zip file comment
        $v_comment = $v_central_dir[&apos;comment&apos;];
        if (isset($p_options[PCLZIP_OPT_COMMENT])) {
            $v_comment = $p_options[PCLZIP_OPT_COMMENT];
        }
        if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {
            $v_comment = $v_comment . $p_options[PCLZIP_OPT_ADD_COMMENT];
        }
        if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {
            $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT] . $v_comment;
        }

        // ----- Calculate the size of the central header
        $v_size = @ftell($this-&gt;zip_fd) - $v_offset;

        // ----- Create the central dir footer
        if (($v_result = $this-&gt;privWriteCentralHeader($v_count + $v_central_dir[&apos;entries&apos;], $v_size, $v_offset, $v_comment)) != 1) {
            // ----- Reset the file list
            unset($v_header_list);
            $this-&gt;privSwapBackMagicQuotes();

            // ----- Return
            return $v_result;
        }

        // ----- Swap back the file descriptor
        $v_swap        = $this-&gt;zip_fd;
        $this-&gt;zip_fd  = $v_zip_temp_fd;
        $v_zip_temp_fd = $v_swap;

        // ----- Close
        $this-&gt;privCloseFd();

        // ----- Close the temporary file
        @fclose($v_zip_temp_fd);

        // ----- Magic quotes trick
        $this-&gt;privSwapBackMagicQuotes();

        // ----- Delete the zip file
        // TBC : I should test the result ...
        @unlink($this-&gt;zipname);

        // ----- Rename the temporary file
        // TBC : I should test the result ...
        //@rename($v_zip_temp_name, $this-&gt;zipname);
        PclZipUtilRename($v_zip_temp_name, $this-&gt;zipname);

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privOpenFd()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function privOpenFd($p_mode)
    {
        $v_result = 1;

        // ----- Look if already open
        if ($this-&gt;zip_fd != 0) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Zip file \&apos;&apos; . $this-&gt;zipname . &apos;\&apos; already open&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Open the zip file
        if (($this-&gt;zip_fd = @fopen($this-&gt;zipname, $p_mode)) == 0) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open archive \&apos;&apos; . $this-&gt;zipname . &apos;\&apos; in &apos; . $p_mode . &apos; mode&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privCloseFd()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function privCloseFd()
    {
        $v_result = 1;

        if ($this-&gt;zip_fd != 0) {
            @fclose($this-&gt;zip_fd);
        }
        $this-&gt;zip_fd = 0;

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privAddList()
    // Description :
    //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is
    //   different from the real path of the file. This is usefull if you want to have PclTar
    //   running in any directory, and memorize relative path from an other directory.
    // Parameters :
    //   $p_list : An array containing the file or directory names to add in the tar
    //   $p_result_list : list of added files with their properties (specially the status field)
    //   $p_add_dir : Path to add in the filename path archived
    //   $p_remove_dir : Path to remove in the filename path archived
    // Return Values :
    // --------------------------------------------------------------------------------
    //  function privAddList($p_list, &amp;$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &amp;$p_options)
    public function privAddList($p_filedescr_list, &amp;$p_result_list, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Add the files
        $v_header_list = array();
        if (($v_result = $this-&gt;privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1) {
            // ----- Return
            return $v_result;
        }

        // ----- Store the offset of the central dir
        $v_offset = @ftell($this-&gt;zip_fd);

        // ----- Create the Central Dir files header
        for ($i = 0, $v_count = 0; $i &lt; sizeof($v_header_list); $i++) {
            // ----- Create the file header
            if ($v_header_list[$i][&apos;status&apos;] == &apos;ok&apos;) {
                if (($v_result = $this-&gt;privWriteCentralFileHeader($v_header_list[$i])) != 1) {
                    // ----- Return
                    return $v_result;
                }
                $v_count++;
            }

            // ----- Transform the header to a &apos;usable&apos; info
            $this-&gt;privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);
        }

        // ----- Zip file comment
        $v_comment = &apos;&apos;;
        if (isset($p_options[PCLZIP_OPT_COMMENT])) {
            $v_comment = $p_options[PCLZIP_OPT_COMMENT];
        }

        // ----- Calculate the size of the central header
        $v_size = @ftell($this-&gt;zip_fd) - $v_offset;

        // ----- Create the central dir footer
        if (($v_result = $this-&gt;privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1) {
            // ----- Reset the file list
            unset($v_header_list);

            // ----- Return
            return $v_result;
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privAddFileList()
    // Description :
    // Parameters :
    //   $p_filedescr_list : An array containing the file description
    //                      or directory names to add in the zip
    //   $p_result_list : list of added files with their properties (specially the status field)
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privAddFileList($p_filedescr_list, &amp;$p_result_list, &amp;$p_options)
    {
        $v_result = 1;
        $v_header = array();

        // ----- Recuperate the current number of elt in list
        $v_nb = sizeof($p_result_list);

        // ----- Loop on the files
        for ($j = 0; ($j &lt; sizeof($p_filedescr_list)) &amp;&amp; ($v_result == 1); $j++) {
            // ----- Format the filename
            $p_filedescr_list[$j][&apos;filename&apos;] = PclZipUtilTranslateWinPath($p_filedescr_list[$j][&apos;filename&apos;], false);

            // ----- Skip empty file names
            // TBC : Can this be possible ? not checked in DescrParseAtt ?
            if ($p_filedescr_list[$j][&apos;filename&apos;] == &quot;&quot;) {
                continue;
            }

            // ----- Check the filename
            if (($p_filedescr_list[$j][&apos;type&apos;] != &apos;virtual_file&apos;) &amp;&amp; (!file_exists($p_filedescr_list[$j][&apos;filename&apos;]))) {
                PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, &quot;File &apos;&quot; . $p_filedescr_list[$j][&apos;filename&apos;] . &quot;&apos; does not exist&quot;);

                return PclZip::errorCode();
            }

            // ----- Look if it is a file or a dir with no all path remove option
            // or a dir with all its path removed
            //      if (   (is_file($p_filedescr_list[$j][&apos;filename&apos;]))
            //          || (   is_dir($p_filedescr_list[$j][&apos;filename&apos;])
            if (($p_filedescr_list[$j][&apos;type&apos;] == &apos;file&apos;) || ($p_filedescr_list[$j][&apos;type&apos;] == &apos;virtual_file&apos;) || (($p_filedescr_list[$j][&apos;type&apos;] == &apos;folder&apos;) &amp;&amp; (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]) || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {

                // ----- Add the file
                $v_result = $this-&gt;privAddFile($p_filedescr_list[$j], $v_header, $p_options);
                if ($v_result != 1) {
                    return $v_result;
                }

                // ----- Store the file infos
                $p_result_list[$v_nb++] = $v_header;
            }
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privAddFile()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privAddFile($p_filedescr, &amp;$p_header, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Working variable
        $p_filename = $p_filedescr[&apos;filename&apos;];

        // TBC : Already done in the fileAtt check ... ?
        if ($p_filename == &quot;&quot;) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, &quot;Invalid file list parameter (invalid or empty list)&quot;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Look for a stored different filename
        /* TBC : Removed
        if (isset($p_filedescr[&apos;stored_filename&apos;])) {
        $v_stored_filename = $p_filedescr[&apos;stored_filename&apos;];
        } else {
        $v_stored_filename = $p_filedescr[&apos;stored_filename&apos;];
        }
        */

        // ----- Set the file properties
        clearstatcache();
        $p_header[&apos;version&apos;]           = 20;
        $p_header[&apos;version_extracted&apos;] = 10;
        $p_header[&apos;flag&apos;]              = 0;
        $p_header[&apos;compression&apos;]       = 0;
        $p_header[&apos;crc&apos;]               = 0;
        $p_header[&apos;compressed_size&apos;]   = 0;
        $p_header[&apos;filename_len&apos;]      = strlen($p_filename);
        $p_header[&apos;extra_len&apos;]         = 0;
        $p_header[&apos;disk&apos;]              = 0;
        $p_header[&apos;internal&apos;]          = 0;
        $p_header[&apos;offset&apos;]            = 0;
        $p_header[&apos;filename&apos;]          = $p_filename;
        // TBC : Removed    $p_header[&apos;stored_filename&apos;] = $v_stored_filename;
        $p_header[&apos;stored_filename&apos;]   = $p_filedescr[&apos;stored_filename&apos;];
        $p_header[&apos;extra&apos;]             = &apos;&apos;;
        $p_header[&apos;status&apos;]            = &apos;ok&apos;;
        $p_header[&apos;index&apos;]             = -1;

        // ----- Look for regular file
        if ($p_filedescr[&apos;type&apos;] == &apos;file&apos;) {
            $p_header[&apos;external&apos;] = 0x00000000;
            $p_header[&apos;size&apos;]     = filesize($p_filename);

        // ----- Look for regular folder
        } elseif ($p_filedescr[&apos;type&apos;] == &apos;folder&apos;) {
            $p_header[&apos;external&apos;] = 0x00000010;
            $p_header[&apos;mtime&apos;]    = filemtime($p_filename);
            $p_header[&apos;size&apos;]     = filesize($p_filename);

        // ----- Look for virtual file
        } elseif ($p_filedescr[&apos;type&apos;] == &apos;virtual_file&apos;) {
            $p_header[&apos;external&apos;] = 0x00000000;
            $p_header[&apos;size&apos;]     = strlen($p_filedescr[&apos;content&apos;]);
        }

        // ----- Look for filetime
        if (isset($p_filedescr[&apos;mtime&apos;])) {
            $p_header[&apos;mtime&apos;] = $p_filedescr[&apos;mtime&apos;];
        } elseif ($p_filedescr[&apos;type&apos;] == &apos;virtual_file&apos;) {
            $p_header[&apos;mtime&apos;] = time();
        } else {
            $p_header[&apos;mtime&apos;] = filemtime($p_filename);
        }

        // ------ Look for file comment
        if (isset($p_filedescr[&apos;comment&apos;])) {
            $p_header[&apos;comment_len&apos;] = strlen($p_filedescr[&apos;comment&apos;]);
            $p_header[&apos;comment&apos;]     = $p_filedescr[&apos;comment&apos;];
        } else {
            $p_header[&apos;comment_len&apos;] = 0;
            $p_header[&apos;comment&apos;]     = &apos;&apos;;
        }

        // ----- Look for pre-add callback
        if (isset($p_options[PCLZIP_CB_PRE_ADD])) {

            // ----- Generate a local information
            $v_local_header = array();
            $this-&gt;privConvertHeader2FileInfo($p_header, $v_local_header);

            // ----- Call the callback
            // Here I do not use call_user_func() because I need to send a reference to the
            // header.
            //      eval(&apos;$v_result = &apos;.$p_options[PCLZIP_CB_PRE_ADD].&apos;(PCLZIP_CB_PRE_ADD, $v_local_header);&apos;);
            $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);
            if ($v_result == 0) {
                // ----- Change the file status
                $p_header[&apos;status&apos;] = &quot;skipped&quot;;
                $v_result           = 1;
            }

            // ----- Update the informations
            // Only some fields can be modified
            if ($p_header[&apos;stored_filename&apos;] != $v_local_header[&apos;stored_filename&apos;]) {
                $p_header[&apos;stored_filename&apos;] = PclZipUtilPathReduction($v_local_header[&apos;stored_filename&apos;]);
            }
        }

        // ----- Look for empty stored filename
        if ($p_header[&apos;stored_filename&apos;] == &quot;&quot;) {
            $p_header[&apos;status&apos;] = &quot;filtered&quot;;
        }

        // ----- Check the path length
        if (strlen($p_header[&apos;stored_filename&apos;]) &gt; 0xFF) {
            $p_header[&apos;status&apos;] = &apos;filename_too_long&apos;;
        }

        // ----- Look if no error, or file not skipped
        if ($p_header[&apos;status&apos;] == &apos;ok&apos;) {

            // ----- Look for a file
            if ($p_filedescr[&apos;type&apos;] == &apos;file&apos;) {
                // ----- Look for using temporary file to zip
                if ((!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) &amp;&amp; (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON]) || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) &amp;&amp; ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] &lt;= $p_header[&apos;size&apos;])))) {
                    $v_result = $this-&gt;privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);
                    if ($v_result &lt; PCLZIP_ERR_NO_ERROR) {
                        return $v_result;
                    }

                // ----- Use &quot;in memory&quot; zip algo
                } else {

                    // ----- Open the source file
                    if (($v_file = @fopen($p_filename, &quot;rb&quot;)) == 0) {
                        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &quot;Unable to open file &apos;$p_filename&apos; in binary read mode&quot;);

                        return PclZip::errorCode();
                    }

                    // ----- Read the file content
                    $v_content = @fread($v_file, $p_header[&apos;size&apos;]);

                    // ----- Close the file
                    @fclose($v_file);

                    // ----- Calculate the CRC
                    $p_header[&apos;crc&apos;] = @crc32($v_content);

                    // ----- Look for no compression
                    if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {
                        // ----- Set header parameters
                        $p_header[&apos;compressed_size&apos;] = $p_header[&apos;size&apos;];
                        $p_header[&apos;compression&apos;]     = 0;

                    // ----- Look for normal compression
                    } else {
                        // ----- Compress the content
                        $v_content = @gzdeflate($v_content);

                        // ----- Set header parameters
                        $p_header[&apos;compressed_size&apos;] = strlen($v_content);
                        $p_header[&apos;compression&apos;]     = 8;
                    }

                    // ----- Call the header generation
                    if (($v_result = $this-&gt;privWriteFileHeader($p_header)) != 1) {
                        @fclose($v_file);

                        return $v_result;
                    }

                    // ----- Write the compressed (or not) content
                    @fwrite($this-&gt;zip_fd, $v_content, $p_header[&apos;compressed_size&apos;]);

                }

            // ----- Look for a virtual file (a file from string)
            } elseif ($p_filedescr[&apos;type&apos;] == &apos;virtual_file&apos;) {

                $v_content = $p_filedescr[&apos;content&apos;];

                // ----- Calculate the CRC
                $p_header[&apos;crc&apos;] = @crc32($v_content);

                // ----- Look for no compression
                if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {
                    // ----- Set header parameters
                    $p_header[&apos;compressed_size&apos;] = $p_header[&apos;size&apos;];
                    $p_header[&apos;compression&apos;]     = 0;

                // ----- Look for normal compression
                } else {
                    // ----- Compress the content
                    $v_content = @gzdeflate($v_content);

                    // ----- Set header parameters
                    $p_header[&apos;compressed_size&apos;] = strlen($v_content);
                    $p_header[&apos;compression&apos;]     = 8;
                }

                // ----- Call the header generation
                if (($v_result = $this-&gt;privWriteFileHeader($p_header)) != 1) {
                    @fclose($v_file);

                    return $v_result;
                }

                // ----- Write the compressed (or not) content
                @fwrite($this-&gt;zip_fd, $v_content, $p_header[&apos;compressed_size&apos;]);

            // ----- Look for a directory
            } elseif ($p_filedescr[&apos;type&apos;] == &apos;folder&apos;) {
                // ----- Look for directory last &apos;/&apos;
                if (@substr($p_header[&apos;stored_filename&apos;], -1) != &apos;/&apos;) {
                    $p_header[&apos;stored_filename&apos;] .= &apos;/&apos;;
                }

                // ----- Set the file properties
                $p_header[&apos;size&apos;]     = 0;
                //$p_header[&apos;external&apos;] = 0x41FF0010;   // Value for a folder : to be checked
                $p_header[&apos;external&apos;] = 0x00000010; // Value for a folder : to be checked

                // ----- Call the header generation
                if (($v_result = $this-&gt;privWriteFileHeader($p_header)) != 1) {
                    return $v_result;
                }
            }
        }

        // ----- Look for post-add callback
        if (isset($p_options[PCLZIP_CB_POST_ADD])) {

            // ----- Generate a local information
            $v_local_header = array();
            $this-&gt;privConvertHeader2FileInfo($p_header, $v_local_header);

            // ----- Call the callback
            // Here I do not use call_user_func() because I need to send a reference to the
            // header.
            //      eval(&apos;$v_result = &apos;.$p_options[PCLZIP_CB_POST_ADD].&apos;(PCLZIP_CB_POST_ADD, $v_local_header);&apos;);
            $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);
            if ($v_result == 0) {
                // ----- Ignored
                $v_result = 1;
            }

            // ----- Update the informations
            // Nothing can be modified
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privAddFileUsingTempFile()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privAddFileUsingTempFile($p_filedescr, &amp;$p_header, &amp;$p_options)
    {
        $v_result = PCLZIP_ERR_NO_ERROR;

        // ----- Working variable
        $p_filename = $p_filedescr[&apos;filename&apos;];

        // ----- Open the source file
        if (($v_file = @fopen($p_filename, &quot;rb&quot;)) == 0) {
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &quot;Unable to open file &apos;$p_filename&apos; in binary read mode&quot;);

            return PclZip::errorCode();
        }

        // ----- Creates a compressed temporary file
        $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid(&apos;pclzip-&apos;) . &apos;.gz&apos;;
        if (($v_file_compressed = @gzopen($v_gzip_temp_name, &quot;wb&quot;)) == 0) {
            fclose($v_file);
            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, &apos;Unable to open temporary file \&apos;&apos; . $v_gzip_temp_name . &apos;\&apos; in binary write mode&apos;);

            return PclZip::errorCode();
        }

        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        $v_size = filesize($p_filename);
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @fread($v_file, $v_read_size);
            //$v_binary_data = pack(&apos;a&apos;.$v_read_size, $v_buffer);
            @gzputs($v_file_compressed, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Close the file
        @fclose($v_file);
        @gzclose($v_file_compressed);

        // ----- Check the minimum file size
        if (filesize($v_gzip_temp_name) &lt; 18) {
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &apos;gzip temporary file \&apos;&apos; . $v_gzip_temp_name . &apos;\&apos; has invalid filesize - should be minimum 18 bytes&apos;);

            return PclZip::errorCode();
        }

        // ----- Extract the compressed attributes
        if (($v_file_compressed = @fopen($v_gzip_temp_name, &quot;rb&quot;)) == 0) {
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open temporary file \&apos;&apos; . $v_gzip_temp_name . &apos;\&apos; in binary read mode&apos;);

            return PclZip::errorCode();
        }

        // ----- Read the gzip file header
        $v_binary_data = @fread($v_file_compressed, 10);
        $v_data_header = unpack(&apos;a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os&apos;, $v_binary_data);

        // ----- Check some parameters
        $v_data_header[&apos;os&apos;] = bin2hex($v_data_header[&apos;os&apos;]);

        // ----- Read the gzip file footer
        @fseek($v_file_compressed, filesize($v_gzip_temp_name) - 8);
        $v_binary_data = @fread($v_file_compressed, 8);
        $v_data_footer = unpack(&apos;Vcrc/Vcompressed_size&apos;, $v_binary_data);

        // ----- Set the attributes
        $p_header[&apos;compression&apos;]     = ord($v_data_header[&apos;cm&apos;]);
        //$p_header[&apos;mtime&apos;] = $v_data_header[&apos;mtime&apos;];
        $p_header[&apos;crc&apos;]             = $v_data_footer[&apos;crc&apos;];
        $p_header[&apos;compressed_size&apos;] = filesize($v_gzip_temp_name) - 18;

        // ----- Close the file
        @fclose($v_file_compressed);

        // ----- Call the header generation
        if (($v_result = $this-&gt;privWriteFileHeader($p_header)) != 1) {
            return $v_result;
        }

        // ----- Add the compressed data
        if (($v_file_compressed = @fopen($v_gzip_temp_name, &quot;rb&quot;)) == 0) {
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open temporary file \&apos;&apos; . $v_gzip_temp_name . &apos;\&apos; in binary read mode&apos;);

            return PclZip::errorCode();
        }

        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        fseek($v_file_compressed, 10);
        $v_size = $p_header[&apos;compressed_size&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @fread($v_file_compressed, $v_read_size);
            //$v_binary_data = pack(&apos;a&apos;.$v_read_size, $v_buffer);
            @fwrite($this-&gt;zip_fd, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Close the file
        @fclose($v_file_compressed);

        // ----- Unlink the temporary file
        @unlink($v_gzip_temp_name);

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privCalculateStoredFilename()
    // Description :
    //   Based on file descriptor properties and global options, this method
    //   calculate the filename that will be stored in the archive.
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privCalculateStoredFilename(&amp;$p_filedescr, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Working variables
        $p_filename = $p_filedescr[&apos;filename&apos;];
        if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {
            $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];
        } else {
            $p_add_dir = &apos;&apos;;
        }
        if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {
            $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];
        } else {
            $p_remove_dir = &apos;&apos;;
        }
        if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {
            $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];
        } else {
            $p_remove_all_dir = 0;
        }

        // ----- Look for full name change
        if (isset($p_filedescr[&apos;new_full_name&apos;])) {
            // ----- Remove drive letter if any
            $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr[&apos;new_full_name&apos;]);

        // ----- Look for path and/or short name change
        } else {

            // ----- Look for short name change
            // Its when we cahnge just the filename but not the path
            if (isset($p_filedescr[&apos;new_short_name&apos;])) {
                $v_path_info = pathinfo($p_filename);
                $v_dir       = &apos;&apos;;
                if ($v_path_info[&apos;dirname&apos;] != &apos;&apos;) {
                    $v_dir = $v_path_info[&apos;dirname&apos;] . &apos;/&apos;;
                }
                $v_stored_filename = $v_dir . $p_filedescr[&apos;new_short_name&apos;];
            } else {
                // ----- Calculate the stored filename
                $v_stored_filename = $p_filename;
            }

            // ----- Look for all path to remove
            if ($p_remove_all_dir) {
                $v_stored_filename = basename($p_filename);

            // ----- Look for partial path remove
            } elseif ($p_remove_dir != &quot;&quot;) {
                if (substr($p_remove_dir, -1) != &apos;/&apos;) {
                    $p_remove_dir .= &quot;/&quot;;
                }

                if ((substr($p_filename, 0, 2) == &quot;./&quot;) || (substr($p_remove_dir, 0, 2) == &quot;./&quot;)) {

                    if ((substr($p_filename, 0, 2) == &quot;./&quot;) &amp;&amp; (substr($p_remove_dir, 0, 2) != &quot;./&quot;)) {
                        $p_remove_dir = &quot;./&quot; . $p_remove_dir;
                    }
                    if ((substr($p_filename, 0, 2) != &quot;./&quot;) &amp;&amp; (substr($p_remove_dir, 0, 2) == &quot;./&quot;)) {
                        $p_remove_dir = substr($p_remove_dir, 2);
                    }
                }

                $v_compare = PclZipUtilPathInclusion($p_remove_dir, $v_stored_filename);
                if ($v_compare &gt; 0) {
                    if ($v_compare == 2) {
                        $v_stored_filename = &quot;&quot;;
                    } else {
                        $v_stored_filename = substr($v_stored_filename, strlen($p_remove_dir));
                    }
                }
            }

            // ----- Remove drive letter if any
            $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);

            // ----- Look for path to add
            if ($p_add_dir != &quot;&quot;) {
                if (substr($p_add_dir, -1) == &quot;/&quot;) {
                    $v_stored_filename = $p_add_dir . $v_stored_filename;
                } else {
                    $v_stored_filename = $p_add_dir . &quot;/&quot; . $v_stored_filename;
                }
            }
        }

        // ----- Filename (reduce the path of stored name)
        $v_stored_filename              = PclZipUtilPathReduction($v_stored_filename);
        $p_filedescr[&apos;stored_filename&apos;] = $v_stored_filename;

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privWriteFileHeader()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privWriteFileHeader(&amp;$p_header)
    {
        $v_result = 1;

        // ----- Store the offset position of the file
        $p_header[&apos;offset&apos;] = ftell($this-&gt;zip_fd);

        // ----- Transform UNIX mtime to DOS format mdate/mtime
        $v_date  = getdate($p_header[&apos;mtime&apos;]);
        $v_mtime = ($v_date[&apos;hours&apos;] &lt;&lt; 11) + ($v_date[&apos;minutes&apos;] &lt;&lt; 5) + $v_date[&apos;seconds&apos;] / 2;
        $v_mdate = (($v_date[&apos;year&apos;] - 1980) &lt;&lt; 9) + ($v_date[&apos;mon&apos;] &lt;&lt; 5) + $v_date[&apos;mday&apos;];

        // ----- Packed data
        $v_binary_data = pack(&quot;VvvvvvVVVvv&quot;, 0x04034b50, $p_header[&apos;version_extracted&apos;], $p_header[&apos;flag&apos;], $p_header[&apos;compression&apos;], $v_mtime, $v_mdate, $p_header[&apos;crc&apos;], $p_header[&apos;compressed_size&apos;], $p_header[&apos;size&apos;], strlen($p_header[&apos;stored_filename&apos;]), $p_header[&apos;extra_len&apos;]);

        // ----- Write the first 148 bytes of the header in the archive
        fputs($this-&gt;zip_fd, $v_binary_data, 30);

        // ----- Write the variable fields
        if (strlen($p_header[&apos;stored_filename&apos;]) != 0) {
            fputs($this-&gt;zip_fd, $p_header[&apos;stored_filename&apos;], strlen($p_header[&apos;stored_filename&apos;]));
        }
        if ($p_header[&apos;extra_len&apos;] != 0) {
            fputs($this-&gt;zip_fd, $p_header[&apos;extra&apos;], $p_header[&apos;extra_len&apos;]);
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privWriteCentralFileHeader()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privWriteCentralFileHeader(&amp;$p_header)
    {
        $v_result = 1;

        // TBC
        //for (reset($p_header); $key = key($p_header); next($p_header)) {
        //}

        // ----- Transform UNIX mtime to DOS format mdate/mtime
        $v_date  = getdate($p_header[&apos;mtime&apos;]);
        $v_mtime = ($v_date[&apos;hours&apos;] &lt;&lt; 11) + ($v_date[&apos;minutes&apos;] &lt;&lt; 5) + $v_date[&apos;seconds&apos;] / 2;
        $v_mdate = (($v_date[&apos;year&apos;] - 1980) &lt;&lt; 9) + ($v_date[&apos;mon&apos;] &lt;&lt; 5) + $v_date[&apos;mday&apos;];

        // ----- Packed data
        $v_binary_data = pack(&quot;VvvvvvvVVVvvvvvVV&quot;, 0x02014b50, $p_header[&apos;version&apos;], $p_header[&apos;version_extracted&apos;], $p_header[&apos;flag&apos;], $p_header[&apos;compression&apos;], $v_mtime, $v_mdate, $p_header[&apos;crc&apos;], $p_header[&apos;compressed_size&apos;], $p_header[&apos;size&apos;], strlen($p_header[&apos;stored_filename&apos;]), $p_header[&apos;extra_len&apos;], $p_header[&apos;comment_len&apos;], $p_header[&apos;disk&apos;], $p_header[&apos;internal&apos;], $p_header[&apos;external&apos;], $p_header[&apos;offset&apos;]);

        // ----- Write the 42 bytes of the header in the zip file
        fputs($this-&gt;zip_fd, $v_binary_data, 46);

        // ----- Write the variable fields
        if (strlen($p_header[&apos;stored_filename&apos;]) != 0) {
            fputs($this-&gt;zip_fd, $p_header[&apos;stored_filename&apos;], strlen($p_header[&apos;stored_filename&apos;]));
        }
        if ($p_header[&apos;extra_len&apos;] != 0) {
            fputs($this-&gt;zip_fd, $p_header[&apos;extra&apos;], $p_header[&apos;extra_len&apos;]);
        }
        if ($p_header[&apos;comment_len&apos;] != 0) {
            fputs($this-&gt;zip_fd, $p_header[&apos;comment&apos;], $p_header[&apos;comment_len&apos;]);
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privWriteCentralHeader()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)
    {
        $v_result = 1;

        // ----- Packed data
        $v_binary_data = pack(&quot;VvvvvVVv&quot;, 0x06054b50, 0, 0, $p_nb_entries, $p_nb_entries, $p_size, $p_offset, strlen($p_comment));

        // ----- Write the 22 bytes of the header in the zip file
        fputs($this-&gt;zip_fd, $v_binary_data, 22);

        // ----- Write the variable fields
        if (strlen($p_comment) != 0) {
            fputs($this-&gt;zip_fd, $p_comment, strlen($p_comment));
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privList()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privList(&amp;$p_list)
    {
        $v_result = 1;

        // ----- Magic quotes trick
        $this-&gt;privDisableMagicQuotes();

        // ----- Open the zip file
        if (($this-&gt;zip_fd = @fopen($this-&gt;zipname, &apos;rb&apos;)) == 0) {
            // ----- Magic quotes trick
            $this-&gt;privSwapBackMagicQuotes();

            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open archive \&apos;&apos; . $this-&gt;zipname . &apos;\&apos; in binary read mode&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Read the central directory informations
        $v_central_dir = array();
        if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1) {
            $this-&gt;privSwapBackMagicQuotes();

            return $v_result;
        }

        // ----- Go to beginning of Central Dir
        @rewind($this-&gt;zip_fd);
        if (@fseek($this-&gt;zip_fd, $v_central_dir[&apos;offset&apos;])) {
            $this-&gt;privSwapBackMagicQuotes();

            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, &apos;Invalid archive size&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Read each entry
        for ($i = 0; $i &lt; $v_central_dir[&apos;entries&apos;]; $i++) {
            // ----- Read the file header
            if (($v_result = $this-&gt;privReadCentralFileHeader($v_header)) != 1) {
                $this-&gt;privSwapBackMagicQuotes();

                return $v_result;
            }
            $v_header[&apos;index&apos;] = $i;

            // ----- Get the only interesting attributes
            $this-&gt;privConvertHeader2FileInfo($v_header, $p_list[$i]);
            unset($v_header);
        }

        // ----- Close the zip file
        $this-&gt;privCloseFd();

        // ----- Magic quotes trick
        $this-&gt;privSwapBackMagicQuotes();

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privConvertHeader2FileInfo()
    // Description :
    //   This function takes the file informations from the central directory
    //   entries and extract the interesting parameters that will be given back.
    //   The resulting file infos are set in the array $p_info
    //     $p_info[&apos;filename&apos;] : Filename with full path. Given by user (add),
    //                           extracted in the filesystem (extract).
    //     $p_info[&apos;stored_filename&apos;] : Stored filename in the archive.
    //     $p_info[&apos;size&apos;] = Size of the file.
    //     $p_info[&apos;compressed_size&apos;] = Compressed size of the file.
    //     $p_info[&apos;mtime&apos;] = Last modification date of the file.
    //     $p_info[&apos;comment&apos;] = Comment associated with the file.
    //     $p_info[&apos;folder&apos;] = true/false : indicates if the entry is a folder or not.
    //     $p_info[&apos;status&apos;] = status of the action on the file.
    //     $p_info[&apos;crc&apos;] = CRC of the file content.
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privConvertHeader2FileInfo($p_header, &amp;$p_info)
    {
        $v_result = 1;

        // ----- Get the interesting attributes
        $v_temp_path               = PclZipUtilPathReduction($p_header[&apos;filename&apos;]);
        $p_info[&apos;filename&apos;]        = $v_temp_path;
        $v_temp_path               = PclZipUtilPathReduction($p_header[&apos;stored_filename&apos;]);
        $p_info[&apos;stored_filename&apos;] = $v_temp_path;
        $p_info[&apos;size&apos;]            = $p_header[&apos;size&apos;];
        $p_info[&apos;compressed_size&apos;] = $p_header[&apos;compressed_size&apos;];
        $p_info[&apos;mtime&apos;]           = $p_header[&apos;mtime&apos;];
        $p_info[&apos;comment&apos;]         = $p_header[&apos;comment&apos;];
        $p_info[&apos;folder&apos;]          = (($p_header[&apos;external&apos;] &amp; 0x00000010) == 0x00000010);
        $p_info[&apos;index&apos;]           = $p_header[&apos;index&apos;];
        $p_info[&apos;status&apos;]          = $p_header[&apos;status&apos;];
        $p_info[&apos;crc&apos;]             = $p_header[&apos;crc&apos;];

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privExtractByRule()
    // Description :
    //   Extract a file or directory depending of rules (by index, by name, ...)
    // Parameters :
    //   $p_file_list : An array where will be placed the properties of each
    //                  extracted file
    //   $p_path : Path to add while writing the extracted files
    //   $p_remove_path : Path to remove (from the file memorized path) while writing the
    //                    extracted files. If the path does not match the file path,
    //                    the file is extracted with its memorized path.
    //                    $p_remove_path does not apply to &apos;list&apos; mode.
    //                    $p_path and $p_remove_path are commulative.
    // Return Values :
    //   1 on success,0 or less on error (see error code list)
    // --------------------------------------------------------------------------------
    public function privExtractByRule(&amp;$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Magic quotes trick
        $this-&gt;privDisableMagicQuotes();

        // ----- Check the path
        if (($p_path == &quot;&quot;) || ((substr($p_path, 0, 1) != &quot;/&quot;) &amp;&amp; (substr($p_path, 0, 3) != &quot;../&quot;) &amp;&amp; (substr($p_path, 1, 2) != &quot;:/&quot;))) {
            $p_path = &quot;./&quot; . $p_path;
        }

        // ----- Reduce the path last (and duplicated) &apos;/&apos;
        if (($p_path != &quot;./&quot;) &amp;&amp; ($p_path != &quot;/&quot;)) {
            // ----- Look for the path end &apos;/&apos;
            while (substr($p_path, -1) == &quot;/&quot;) {
                $p_path = substr($p_path, 0, strlen($p_path) - 1);
            }
        }

        // ----- Look for path to remove format (should end by /)
        if (($p_remove_path != &quot;&quot;) &amp;&amp; (substr($p_remove_path, -1) != &apos;/&apos;)) {
            $p_remove_path .= &apos;/&apos;;
        }
        $p_remove_path_size = strlen($p_remove_path);

        // ----- Open the zip file
        if (($v_result = $this-&gt;privOpenFd(&apos;rb&apos;)) != 1) {
            $this-&gt;privSwapBackMagicQuotes();

            return $v_result;
        }

        // ----- Read the central directory informations
        $v_central_dir = array();
        if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1) {
            // ----- Close the zip file
            $this-&gt;privCloseFd();
            $this-&gt;privSwapBackMagicQuotes();

            return $v_result;
        }

        // ----- Start at beginning of Central Dir
        $v_pos_entry = $v_central_dir[&apos;offset&apos;];

        // ----- Read each entry
        $j_start = 0;
        for ($i = 0, $v_nb_extracted = 0; $i &lt; $v_central_dir[&apos;entries&apos;]; $i++) {

            // ----- Read next Central dir entry
            @rewind($this-&gt;zip_fd);
            if (@fseek($this-&gt;zip_fd, $v_pos_entry)) {
                // ----- Close the zip file
                $this-&gt;privCloseFd();
                $this-&gt;privSwapBackMagicQuotes();

                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, &apos;Invalid archive size&apos;);

                // ----- Return
                return PclZip::errorCode();
            }

            // ----- Read the file header
            $v_header = array();
            if (($v_result = $this-&gt;privReadCentralFileHeader($v_header)) != 1) {
                // ----- Close the zip file
                $this-&gt;privCloseFd();
                $this-&gt;privSwapBackMagicQuotes();

                return $v_result;
            }

            // ----- Store the index
            $v_header[&apos;index&apos;] = $i;

            // ----- Store the file position
            $v_pos_entry = ftell($this-&gt;zip_fd);

            // ----- Look for the specific extract rules
            $v_extract = false;

            // ----- Look for extract by name rule
            if ((isset($p_options[PCLZIP_OPT_BY_NAME])) &amp;&amp; ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {

                // ----- Look if the filename is in the list
                for ($j = 0; ($j &lt; sizeof($p_options[PCLZIP_OPT_BY_NAME])) &amp;&amp; (!$v_extract); $j++) {

                    // ----- Look for a directory
                    if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == &quot;/&quot;) {

                        // ----- Look if the directory is in the filename path
                        if ((strlen($v_header[&apos;stored_filename&apos;]) &gt; strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) &amp;&amp; (substr($v_header[&apos;stored_filename&apos;], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {
                            $v_extract = true;
                        }

                    // ----- Look for a filename
                    } elseif ($v_header[&apos;stored_filename&apos;] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {
                        $v_extract = true;
                    }
                }
            // ----- Look for extract by ereg rule
            // ereg() is deprecated with PHP 5.3
            /*
            elseif (   (isset($p_options[PCLZIP_OPT_BY_EREG]))
            &amp;&amp; ($p_options[PCLZIP_OPT_BY_EREG] != &quot;&quot;)) {

            if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header[&apos;stored_filename&apos;])) {
            $v_extract = true;
            }
            }
            */

            // ----- Look for extract by preg rule
            } elseif ((isset($p_options[PCLZIP_OPT_BY_PREG])) &amp;&amp; ($p_options[PCLZIP_OPT_BY_PREG] != &quot;&quot;)) {

                if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header[&apos;stored_filename&apos;])) {
                    $v_extract = true;
                }

            // ----- Look for extract by index rule
            } elseif ((isset($p_options[PCLZIP_OPT_BY_INDEX])) &amp;&amp; ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {

                // ----- Look if the index is in the list
                for ($j = $j_start; ($j &lt; sizeof($p_options[PCLZIP_OPT_BY_INDEX])) &amp;&amp; (!$v_extract); $j++) {

                    if (($i &gt;= $p_options[PCLZIP_OPT_BY_INDEX][$j][&apos;start&apos;]) &amp;&amp; ($i &lt;= $p_options[PCLZIP_OPT_BY_INDEX][$j][&apos;end&apos;])) {
                        $v_extract = true;
                    }
                    if ($i &gt;= $p_options[PCLZIP_OPT_BY_INDEX][$j][&apos;end&apos;]) {
                        $j_start = $j + 1;
                    }

                    if ($p_options[PCLZIP_OPT_BY_INDEX][$j][&apos;start&apos;] &gt; $i) {
                        break;
                    }
                }

            // ----- Look for no rule, which means extract all the archive
            } else {
                $v_extract = true;
            }

            // ----- Check compression method
            if (($v_extract) &amp;&amp; (($v_header[&apos;compression&apos;] != 8) &amp;&amp; ($v_header[&apos;compression&apos;] != 0))) {
                $v_header[&apos;status&apos;] = &apos;unsupported_compression&apos;;

                // ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) &amp;&amp; ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {

                    $this-&gt;privSwapBackMagicQuotes();

                    PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION, &quot;Filename &apos;&quot; . $v_header[&apos;stored_filename&apos;] . &quot;&apos; is &quot; . &quot;compressed by an unsupported compression &quot; . &quot;method (&quot; . $v_header[&apos;compression&apos;] . &quot;) &quot;);

                    return PclZip::errorCode();
                }
            }

            // ----- Check encrypted files
            if (($v_extract) &amp;&amp; (($v_header[&apos;flag&apos;] &amp; 1) == 1)) {
                $v_header[&apos;status&apos;] = &apos;unsupported_encryption&apos;;

                // ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) &amp;&amp; ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {

                    $this-&gt;privSwapBackMagicQuotes();

                    PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, &quot;Unsupported encryption for &quot; . &quot; filename &apos;&quot; . $v_header[&apos;stored_filename&apos;] . &quot;&apos;&quot;);

                    return PclZip::errorCode();
                }
            }

            // ----- Look for real extraction
            if (($v_extract) &amp;&amp; ($v_header[&apos;status&apos;] != &apos;ok&apos;)) {
                $v_result = $this-&gt;privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++]);
                if ($v_result != 1) {
                    $this-&gt;privCloseFd();
                    $this-&gt;privSwapBackMagicQuotes();

                    return $v_result;
                }

                $v_extract = false;
            }

            // ----- Look for real extraction
            if ($v_extract) {

                // ----- Go to the file position
                @rewind($this-&gt;zip_fd);
                if (@fseek($this-&gt;zip_fd, $v_header[&apos;offset&apos;])) {
                    // ----- Close the zip file
                    $this-&gt;privCloseFd();

                    $this-&gt;privSwapBackMagicQuotes();

                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, &apos;Invalid archive size&apos;);

                    // ----- Return
                    return PclZip::errorCode();
                }

                // ----- Look for extraction as string
                if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {

                    $v_string = &apos;&apos;;

                    // ----- Extracting the file
                    $v_result1 = $this-&gt;privExtractFileAsString($v_header, $v_string, $p_options);
                    if ($v_result1 &lt; 1) {
                        $this-&gt;privCloseFd();
                        $this-&gt;privSwapBackMagicQuotes();

                        return $v_result1;
                    }

                    // ----- Get the only interesting attributes
                    if (($v_result = $this-&gt;privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1) {
                        // ----- Close the zip file
                        $this-&gt;privCloseFd();
                        $this-&gt;privSwapBackMagicQuotes();

                        return $v_result;
                    }

                    // ----- Set the file content
                    $p_file_list[$v_nb_extracted][&apos;content&apos;] = $v_string;

                    // ----- Next extracted file
                    $v_nb_extracted++;

                    // ----- Look for user callback abort
                    if ($v_result1 == 2) {
                        break;
                    }

                // ----- Look for extraction in standard output
                } elseif ((isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) &amp;&amp; ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {
                    // ----- Extracting the file in standard output
                    $v_result1 = $this-&gt;privExtractFileInOutput($v_header, $p_options);
                    if ($v_result1 &lt; 1) {
                        $this-&gt;privCloseFd();
                        $this-&gt;privSwapBackMagicQuotes();

                        return $v_result1;
                    }

                    // ----- Get the only interesting attributes
                    if (($v_result = $this-&gt;privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {
                        $this-&gt;privCloseFd();
                        $this-&gt;privSwapBackMagicQuotes();

                        return $v_result;
                    }

                    // ----- Look for user callback abort
                    if ($v_result1 == 2) {
                        break;
                    }

                // ----- Look for normal extraction
                } else {
                    // ----- Extracting the file
                    $v_result1 = $this-&gt;privExtractFile($v_header, $p_path, $p_remove_path, $p_remove_all_path, $p_options);
                    if ($v_result1 &lt; 1) {
                        $this-&gt;privCloseFd();
                        $this-&gt;privSwapBackMagicQuotes();

                        return $v_result1;
                    }

                    // ----- Get the only interesting attributes
                    if (($v_result = $this-&gt;privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {
                        // ----- Close the zip file
                        $this-&gt;privCloseFd();
                        $this-&gt;privSwapBackMagicQuotes();

                        return $v_result;
                    }

                    // ----- Look for user callback abort
                    if ($v_result1 == 2) {
                        break;
                    }
                }
            }
        }

        // ----- Close the zip file
        $this-&gt;privCloseFd();
        $this-&gt;privSwapBackMagicQuotes();

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privExtractFile()
    // Description :
    // Parameters :
    // Return Values :
    //
    // 1 : ... ?
    // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback
    // --------------------------------------------------------------------------------
    public function privExtractFile(&amp;$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Read the file header
        if (($v_result = $this-&gt;privReadFileHeader($v_header)) != 1) {
            // ----- Return
            return $v_result;
        }

        // ----- Check that the file header is coherent with $p_entry info
        if ($this-&gt;privCheckFileHeaders($v_header, $p_entry) != 1) {
            // TBC
        }

        // ----- Look for all path to remove
        if ($p_remove_all_path == true) {
            // ----- Look for folder entry that not need to be extracted
            if (($p_entry[&apos;external&apos;] &amp; 0x00000010) == 0x00000010) {

                $p_entry[&apos;status&apos;] = &quot;filtered&quot;;

                return $v_result;
            }

            // ----- Get the basename of the path
            $p_entry[&apos;filename&apos;] = basename($p_entry[&apos;filename&apos;]);

        // ----- Look for path to remove
        } elseif ($p_remove_path != &quot;&quot;) {
            if (PclZipUtilPathInclusion($p_remove_path, $p_entry[&apos;filename&apos;]) == 2) {

                // ----- Change the file status
                $p_entry[&apos;status&apos;] = &quot;filtered&quot;;

                // ----- Return
                return $v_result;
            }

            $p_remove_path_size = strlen($p_remove_path);
            if (substr($p_entry[&apos;filename&apos;], 0, $p_remove_path_size) == $p_remove_path) {

                // ----- Remove the path
                $p_entry[&apos;filename&apos;] = substr($p_entry[&apos;filename&apos;], $p_remove_path_size);

            }
        }

        // ----- Add the path
        if ($p_path != &apos;&apos;) {
            $p_entry[&apos;filename&apos;] = $p_path . &quot;/&quot; . $p_entry[&apos;filename&apos;];
        }

        // ----- Check a base_dir_restriction
        if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {
            $v_inclusion = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION], $p_entry[&apos;filename&apos;]);
            if ($v_inclusion == 0) {

                PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION, &quot;Filename &apos;&quot; . $p_entry[&apos;filename&apos;] . &quot;&apos; is &quot; . &quot;outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION&quot;);

                return PclZip::errorCode();
            }
        }

        // ----- Look for pre-extract callback
        if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {

            // ----- Generate a local information
            $v_local_header = array();
            $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);

            // ----- Call the callback
            // Here I do not use call_user_func() because I need to send a reference to the
            // header.
            //      eval(&apos;$v_result = &apos;.$p_options[PCLZIP_CB_PRE_EXTRACT].&apos;(PCLZIP_CB_PRE_EXTRACT, $v_local_header);&apos;);
            $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);
            if ($v_result == 0) {
                // ----- Change the file status
                $p_entry[&apos;status&apos;] = &quot;skipped&quot;;
                $v_result          = 1;
            }

            // ----- Look for abort result
            if ($v_result == 2) {
                // ----- This status is internal and will be changed in &apos;skipped&apos;
                $p_entry[&apos;status&apos;] = &quot;aborted&quot;;
                $v_result          = PCLZIP_ERR_USER_ABORTED;
            }

            // ----- Update the informations
            // Only some fields can be modified
            $p_entry[&apos;filename&apos;] = $v_local_header[&apos;filename&apos;];
        }

        // ----- Look if extraction should be done
        if ($p_entry[&apos;status&apos;] == &apos;ok&apos;) {

            // ----- Look for specific actions while the file exist
            if (file_exists($p_entry[&apos;filename&apos;])) {

                // ----- Look if file is a directory
                if (is_dir($p_entry[&apos;filename&apos;])) {

                    // ----- Change the file status
                    $p_entry[&apos;status&apos;] = &quot;already_a_directory&quot;;

                    // ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                    // For historical reason first PclZip implementation does not stop
                    // when this kind of error occurs.
                    if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) &amp;&amp; ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {

                        PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY, &quot;Filename &apos;&quot; . $p_entry[&apos;filename&apos;] . &quot;&apos; is &quot; . &quot;already used by an existing directory&quot;);

                        return PclZip::errorCode();
                    }

                // ----- Look if file is write protected
                } elseif (!is_writeable($p_entry[&apos;filename&apos;])) {

                    // ----- Change the file status
                    $p_entry[&apos;status&apos;] = &quot;write_protected&quot;;

                    // ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                    // For historical reason first PclZip implementation does not stop
                    // when this kind of error occurs.
                    if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) &amp;&amp; ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {

                        PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, &quot;Filename &apos;&quot; . $p_entry[&apos;filename&apos;] . &quot;&apos; exists &quot; . &quot;and is write protected&quot;);

                        return PclZip::errorCode();
                    }

                // ----- Look if the extracted file is older
                } elseif (filemtime($p_entry[&apos;filename&apos;]) &gt; $p_entry[&apos;mtime&apos;]) {
                    // ----- Change the file status
                    if ((isset($p_options[PCLZIP_OPT_REPLACE_NEWER])) &amp;&amp; ($p_options[PCLZIP_OPT_REPLACE_NEWER] === true)) {
                    } else {
                        $p_entry[&apos;status&apos;] = &quot;newer_exist&quot;;

                        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR
                        // For historical reason first PclZip implementation does not stop
                        // when this kind of error occurs.
                        if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) &amp;&amp; ($p_options[PCLZIP_OPT_STOP_ON_ERROR] === true)) {

                            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, &quot;Newer version of &apos;&quot; . $p_entry[&apos;filename&apos;] . &quot;&apos; exists &quot; . &quot;and option PCLZIP_OPT_REPLACE_NEWER is not selected&quot;);

                            return PclZip::errorCode();
                        }
                    }
                } else {
                }

            // ----- Check the directory availability and create it if necessary
            } else {
                if ((($p_entry[&apos;external&apos;] &amp; 0x00000010) == 0x00000010) || (substr($p_entry[&apos;filename&apos;], -1) == &apos;/&apos;)) {
                    $v_dir_to_check = $p_entry[&apos;filename&apos;];
                } elseif (!strstr($p_entry[&apos;filename&apos;], &quot;/&quot;)) {
                    $v_dir_to_check = &quot;&quot;;
                } else {
                    $v_dir_to_check = dirname($p_entry[&apos;filename&apos;]);
                }

                if (($v_result = $this-&gt;privDirCheck($v_dir_to_check, (($p_entry[&apos;external&apos;] &amp; 0x00000010) == 0x00000010))) != 1) {

                    // ----- Change the file status
                    $p_entry[&apos;status&apos;] = &quot;path_creation_fail&quot;;

                    // ----- Return
                    //return $v_result;
                    $v_result = 1;
                }
            }
        }

        // ----- Look if extraction should be done
        if ($p_entry[&apos;status&apos;] == &apos;ok&apos;) {

            // ----- Do the extraction (if not a folder)
            if (!(($p_entry[&apos;external&apos;] &amp; 0x00000010) == 0x00000010)) {
                // ----- Look for not compressed file
                if ($p_entry[&apos;compression&apos;] == 0) {

                    // ----- Opening destination file
                    if (($v_dest_file = @fopen($p_entry[&apos;filename&apos;], &apos;wb&apos;)) == 0) {

                        // ----- Change the file status
                        $p_entry[&apos;status&apos;] = &quot;write_error&quot;;

                        // ----- Return
                        return $v_result;
                    }

                    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
                    $v_size = $p_entry[&apos;compressed_size&apos;];
                    while ($v_size != 0) {
                        $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
                        $v_buffer    = @fread($this-&gt;zip_fd, $v_read_size);
                        /* Try to speed up the code
                        $v_binary_data = pack(&apos;a&apos;.$v_read_size, $v_buffer);
                        @fwrite($v_dest_file, $v_binary_data, $v_read_size);
                        */
                        @fwrite($v_dest_file, $v_buffer, $v_read_size);
                        $v_size -= $v_read_size;
                    }

                    // ----- Closing the destination file
                    fclose($v_dest_file);

                    // ----- Change the file mtime
                    touch($p_entry[&apos;filename&apos;], $p_entry[&apos;mtime&apos;]);

                } else {
                    // ----- TBC
                    // Need to be finished
                    if (($p_entry[&apos;flag&apos;] &amp; 1) == 1) {
                        PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, &apos;File \&apos;&apos; . $p_entry[&apos;filename&apos;] . &apos;\&apos; is encrypted. Encrypted files are not supported.&apos;);

                        return PclZip::errorCode();
                    }

                    // ----- Look for using temporary file to unzip
                    if ((!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) &amp;&amp; (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON]) || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) &amp;&amp; ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] &lt;= $p_entry[&apos;size&apos;])))) {
                        $v_result = $this-&gt;privExtractFileUsingTempFile($p_entry, $p_options);
                        if ($v_result &lt; PCLZIP_ERR_NO_ERROR) {
                            return $v_result;
                        }

                    // ----- Look for extract in memory
                    } else {

                        // ----- Read the compressed file in a buffer (one shot)
                        $v_buffer = @fread($this-&gt;zip_fd, $p_entry[&apos;compressed_size&apos;]);

                        // ----- Decompress the file
                        $v_file_content = @gzinflate($v_buffer);
                        unset($v_buffer);
                        if ($v_file_content === false) {

                            // ----- Change the file status
                            // TBC
                            $p_entry[&apos;status&apos;] = &quot;error&quot;;

                            return $v_result;
                        }

                        // ----- Opening destination file
                        if (($v_dest_file = @fopen($p_entry[&apos;filename&apos;], &apos;wb&apos;)) == 0) {

                            // ----- Change the file status
                            $p_entry[&apos;status&apos;] = &quot;write_error&quot;;

                            return $v_result;
                        }

                        // ----- Write the uncompressed data
                        @fwrite($v_dest_file, $v_file_content, $p_entry[&apos;size&apos;]);
                        unset($v_file_content);

                        // ----- Closing the destination file
                        @fclose($v_dest_file);

                    }

                    // ----- Change the file mtime
                    @touch($p_entry[&apos;filename&apos;], $p_entry[&apos;mtime&apos;]);
                }

                // ----- Look for chmod option
                if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {

                    // ----- Change the mode of the file
                    @chmod($p_entry[&apos;filename&apos;], $p_options[PCLZIP_OPT_SET_CHMOD]);
                }

            }
        }

        // ----- Change abort status
        if ($p_entry[&apos;status&apos;] == &quot;aborted&quot;) {
            $p_entry[&apos;status&apos;] = &quot;skipped&quot;;

        // ----- Look for post-extract callback
        } elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {

            // ----- Generate a local information
            $v_local_header = array();
            $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);

            // ----- Call the callback
            // Here I do not use call_user_func() because I need to send a reference to the
            // header.
            //      eval(&apos;$v_result = &apos;.$p_options[PCLZIP_CB_POST_EXTRACT].&apos;(PCLZIP_CB_POST_EXTRACT, $v_local_header);&apos;);
            $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);

            // ----- Look for abort result
            if ($v_result == 2) {
                $v_result = PCLZIP_ERR_USER_ABORTED;
            }
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privExtractFileUsingTempFile()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privExtractFileUsingTempFile(&amp;$p_entry, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Creates a temporary file
        $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid(&apos;pclzip-&apos;) . &apos;.gz&apos;;
        if (($v_dest_file = @fopen($v_gzip_temp_name, &quot;wb&quot;)) == 0) {
            fclose($v_file);
            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, &apos;Unable to open temporary file \&apos;&apos; . $v_gzip_temp_name . &apos;\&apos; in binary write mode&apos;);

            return PclZip::errorCode();
        }

        // ----- Write gz file format header
        $v_binary_data = pack(&apos;va1a1Va1a1&apos;, 0x8b1f, Chr($p_entry[&apos;compression&apos;]), Chr(0x00), time(), Chr(0x00), Chr(3));
        @fwrite($v_dest_file, $v_binary_data, 10);

        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        $v_size = $p_entry[&apos;compressed_size&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @fread($this-&gt;zip_fd, $v_read_size);
            //$v_binary_data = pack(&apos;a&apos;.$v_read_size, $v_buffer);
            @fwrite($v_dest_file, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Write gz file format footer
        $v_binary_data = pack(&apos;VV&apos;, $p_entry[&apos;crc&apos;], $p_entry[&apos;size&apos;]);
        @fwrite($v_dest_file, $v_binary_data, 8);

        // ----- Close the temporary file
        @fclose($v_dest_file);

        // ----- Opening destination file
        if (($v_dest_file = @fopen($p_entry[&apos;filename&apos;], &apos;wb&apos;)) == 0) {
            $p_entry[&apos;status&apos;] = &quot;write_error&quot;;

            return $v_result;
        }

        // ----- Open the temporary gz file
        if (($v_src_file = @gzopen($v_gzip_temp_name, &apos;rb&apos;)) == 0) {
            @fclose($v_dest_file);
            $p_entry[&apos;status&apos;] = &quot;read_error&quot;;
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open temporary file \&apos;&apos; . $v_gzip_temp_name . &apos;\&apos; in binary read mode&apos;);

            return PclZip::errorCode();
        }

        // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks
        $v_size = $p_entry[&apos;size&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @gzread($v_src_file, $v_read_size);
            //$v_binary_data = pack(&apos;a&apos;.$v_read_size, $v_buffer);
            @fwrite($v_dest_file, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }
        @fclose($v_dest_file);
        @gzclose($v_src_file);

        // ----- Delete the temporary file
        @unlink($v_gzip_temp_name);

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privExtractFileInOutput()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privExtractFileInOutput(&amp;$p_entry, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Read the file header
        if (($v_result = $this-&gt;privReadFileHeader($v_header)) != 1) {
            return $v_result;
        }

        // ----- Check that the file header is coherent with $p_entry info
        if ($this-&gt;privCheckFileHeaders($v_header, $p_entry) != 1) {
            // TBC
        }

        // ----- Look for pre-extract callback
        if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {

            // ----- Generate a local information
            $v_local_header = array();
            $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);

            // ----- Call the callback
            // Here I do not use call_user_func() because I need to send a reference to the
            // header.
            //      eval(&apos;$v_result = &apos;.$p_options[PCLZIP_CB_PRE_EXTRACT].&apos;(PCLZIP_CB_PRE_EXTRACT, $v_local_header);&apos;);
            $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);
            if ($v_result == 0) {
                // ----- Change the file status
                $p_entry[&apos;status&apos;] = &quot;skipped&quot;;
                $v_result          = 1;
            }

            // ----- Look for abort result
            if ($v_result == 2) {
                // ----- This status is internal and will be changed in &apos;skipped&apos;
                $p_entry[&apos;status&apos;] = &quot;aborted&quot;;
                $v_result          = PCLZIP_ERR_USER_ABORTED;
            }

            // ----- Update the informations
            // Only some fields can be modified
            $p_entry[&apos;filename&apos;] = $v_local_header[&apos;filename&apos;];
        }

        // ----- Trace

        // ----- Look if extraction should be done
        if ($p_entry[&apos;status&apos;] == &apos;ok&apos;) {

            // ----- Do the extraction (if not a folder)
            if (!(($p_entry[&apos;external&apos;] &amp; 0x00000010) == 0x00000010)) {
                // ----- Look for not compressed file
                if ($p_entry[&apos;compressed_size&apos;] == $p_entry[&apos;size&apos;]) {

                    // ----- Read the file in a buffer (one shot)
                    $v_buffer = @fread($this-&gt;zip_fd, $p_entry[&apos;compressed_size&apos;]);

                    // ----- Send the file to the output
                    echo $v_buffer;
                    unset($v_buffer);
                } else {

                    // ----- Read the compressed file in a buffer (one shot)
                    $v_buffer = @fread($this-&gt;zip_fd, $p_entry[&apos;compressed_size&apos;]);

                    // ----- Decompress the file
                    $v_file_content = gzinflate($v_buffer);
                    unset($v_buffer);

                    // ----- Send the file to the output
                    echo $v_file_content;
                    unset($v_file_content);
                }
            }
        }

        // ----- Change abort status
        if ($p_entry[&apos;status&apos;] == &quot;aborted&quot;) {
            $p_entry[&apos;status&apos;] = &quot;skipped&quot;;

        // ----- Look for post-extract callback
        } elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {

            // ----- Generate a local information
            $v_local_header = array();
            $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);

            // ----- Call the callback
            // Here I do not use call_user_func() because I need to send a reference to the
            // header.
            //      eval(&apos;$v_result = &apos;.$p_options[PCLZIP_CB_POST_EXTRACT].&apos;(PCLZIP_CB_POST_EXTRACT, $v_local_header);&apos;);
            $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);

            // ----- Look for abort result
            if ($v_result == 2) {
                $v_result = PCLZIP_ERR_USER_ABORTED;
            }
        }

        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privExtractFileAsString()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privExtractFileAsString(&amp;$p_entry, &amp;$p_string, &amp;$p_options)
    {
        $v_result = 1;

        // ----- Read the file header
        $v_header = array();
        if (($v_result = $this-&gt;privReadFileHeader($v_header)) != 1) {
            // ----- Return
            return $v_result;
        }

        // ----- Check that the file header is coherent with $p_entry info
        if ($this-&gt;privCheckFileHeaders($v_header, $p_entry) != 1) {
            // TBC
        }

        // ----- Look for pre-extract callback
        if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {

            // ----- Generate a local information
            $v_local_header = array();
            $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);

            // ----- Call the callback
            // Here I do not use call_user_func() because I need to send a reference to the
            // header.
            //      eval(&apos;$v_result = &apos;.$p_options[PCLZIP_CB_PRE_EXTRACT].&apos;(PCLZIP_CB_PRE_EXTRACT, $v_local_header);&apos;);
            $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);
            if ($v_result == 0) {
                // ----- Change the file status
                $p_entry[&apos;status&apos;] = &quot;skipped&quot;;
                $v_result          = 1;
            }

            // ----- Look for abort result
            if ($v_result == 2) {
                // ----- This status is internal and will be changed in &apos;skipped&apos;
                $p_entry[&apos;status&apos;] = &quot;aborted&quot;;
                $v_result          = PCLZIP_ERR_USER_ABORTED;
            }

            // ----- Update the informations
            // Only some fields can be modified
            $p_entry[&apos;filename&apos;] = $v_local_header[&apos;filename&apos;];
        }

        // ----- Look if extraction should be done
        if ($p_entry[&apos;status&apos;] == &apos;ok&apos;) {

            // ----- Do the extraction (if not a folder)
            if (!(($p_entry[&apos;external&apos;] &amp; 0x00000010) == 0x00000010)) {
                // ----- Look for not compressed file
                //      if ($p_entry[&apos;compressed_size&apos;] == $p_entry[&apos;size&apos;])
                if ($p_entry[&apos;compression&apos;] == 0) {

                    // ----- Reading the file
                    $p_string = @fread($this-&gt;zip_fd, $p_entry[&apos;compressed_size&apos;]);
                } else {

                    // ----- Reading the file
                    $v_data = @fread($this-&gt;zip_fd, $p_entry[&apos;compressed_size&apos;]);

                    // ----- Decompress the file
                    if (($p_string = @gzinflate($v_data)) === false) {
                        // TBC
                    }
                }

                // ----- Trace
            } else {
                // TBC : error : can not extract a folder in a string
            }

        }

        // ----- Change abort status
        if ($p_entry[&apos;status&apos;] == &quot;aborted&quot;) {
            $p_entry[&apos;status&apos;] = &quot;skipped&quot;;

        // ----- Look for post-extract callback
        } elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {

            // ----- Generate a local information
            $v_local_header = array();
            $this-&gt;privConvertHeader2FileInfo($p_entry, $v_local_header);

            // ----- Swap the content to header
            $v_local_header[&apos;content&apos;] = $p_string;
            $p_string                  = &apos;&apos;;

            // ----- Call the callback
            // Here I do not use call_user_func() because I need to send a reference to the
            // header.
            //      eval(&apos;$v_result = &apos;.$p_options[PCLZIP_CB_POST_EXTRACT].&apos;(PCLZIP_CB_POST_EXTRACT, $v_local_header);&apos;);
            $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);

            // ----- Swap back the content to header
            $p_string = $v_local_header[&apos;content&apos;];
            unset($v_local_header[&apos;content&apos;]);

            // ----- Look for abort result
            if ($v_result == 2) {
                $v_result = PCLZIP_ERR_USER_ABORTED;
            }
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privReadFileHeader()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privReadFileHeader(&amp;$p_header)
    {
        $v_result = 1;

        // ----- Read the 4 bytes signature
        $v_binary_data = @fread($this-&gt;zip_fd, 4);
        $v_data        = unpack(&apos;Vid&apos;, $v_binary_data);

        // ----- Check signature
        if ($v_data[&apos;id&apos;] != 0x04034b50) {

            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &apos;Invalid archive structure&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Read the first 42 bytes of the header
        $v_binary_data = fread($this-&gt;zip_fd, 26);

        // ----- Look for invalid block size
        if (strlen($v_binary_data) != 26) {
            $p_header[&apos;filename&apos;] = &quot;&quot;;
            $p_header[&apos;status&apos;]   = &quot;invalid_header&quot;;

            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &quot;Invalid block size : &quot; . strlen($v_binary_data));

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Extract the values
        $v_data = unpack(&apos;vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len&apos;, $v_binary_data);

        // ----- Get filename
        $p_header[&apos;filename&apos;] = fread($this-&gt;zip_fd, $v_data[&apos;filename_len&apos;]);

        // ----- Get extra_fields
        if ($v_data[&apos;extra_len&apos;] != 0) {
            $p_header[&apos;extra&apos;] = fread($this-&gt;zip_fd, $v_data[&apos;extra_len&apos;]);
        } else {
            $p_header[&apos;extra&apos;] = &apos;&apos;;
        }

        // ----- Extract properties
        $p_header[&apos;version_extracted&apos;] = $v_data[&apos;version&apos;];
        $p_header[&apos;compression&apos;]       = $v_data[&apos;compression&apos;];
        $p_header[&apos;size&apos;]              = $v_data[&apos;size&apos;];
        $p_header[&apos;compressed_size&apos;]   = $v_data[&apos;compressed_size&apos;];
        $p_header[&apos;crc&apos;]               = $v_data[&apos;crc&apos;];
        $p_header[&apos;flag&apos;]              = $v_data[&apos;flag&apos;];
        $p_header[&apos;filename_len&apos;]      = $v_data[&apos;filename_len&apos;];

        // ----- Recuperate date in UNIX format
        $p_header[&apos;mdate&apos;] = $v_data[&apos;mdate&apos;];
        $p_header[&apos;mtime&apos;] = $v_data[&apos;mtime&apos;];
        if ($p_header[&apos;mdate&apos;] &amp;&amp; $p_header[&apos;mtime&apos;]) {
            // ----- Extract time
            $v_hour    = ($p_header[&apos;mtime&apos;] &amp; 0xF800) &gt;&gt; 11;
            $v_minute  = ($p_header[&apos;mtime&apos;] &amp; 0x07E0) &gt;&gt; 5;
            $v_seconde = ($p_header[&apos;mtime&apos;] &amp; 0x001F) * 2;

            // ----- Extract date
            $v_year  = (($p_header[&apos;mdate&apos;] &amp; 0xFE00) &gt;&gt; 9) + 1980;
            $v_month = ($p_header[&apos;mdate&apos;] &amp; 0x01E0) &gt;&gt; 5;
            $v_day   = $p_header[&apos;mdate&apos;] &amp; 0x001F;

            // ----- Get UNIX date format
            $p_header[&apos;mtime&apos;] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);

        } else {
            $p_header[&apos;mtime&apos;] = time();
        }

        // TBC
        //for (reset($v_data); $key = key($v_data); next($v_data)) {
        //}

        // ----- Set the stored filename
        $p_header[&apos;stored_filename&apos;] = $p_header[&apos;filename&apos;];

        // ----- Set the status field
        $p_header[&apos;status&apos;] = &quot;ok&quot;;

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privReadCentralFileHeader()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privReadCentralFileHeader(&amp;$p_header)
    {
        $v_result = 1;

        // ----- Read the 4 bytes signature
        $v_binary_data = @fread($this-&gt;zip_fd, 4);
        $v_data        = unpack(&apos;Vid&apos;, $v_binary_data);

        // ----- Check signature
        if ($v_data[&apos;id&apos;] != 0x02014b50) {

            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &apos;Invalid archive structure&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Read the first 42 bytes of the header
        $v_binary_data = fread($this-&gt;zip_fd, 42);

        // ----- Look for invalid block size
        if (strlen($v_binary_data) != 42) {
            $p_header[&apos;filename&apos;] = &quot;&quot;;
            $p_header[&apos;status&apos;]   = &quot;invalid_header&quot;;

            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &quot;Invalid block size : &quot; . strlen($v_binary_data));

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Extract the values
        $p_header = unpack(&apos;vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset&apos;, $v_binary_data);

        // ----- Get filename
        if ($p_header[&apos;filename_len&apos;] != 0) {
            $p_header[&apos;filename&apos;] = fread($this-&gt;zip_fd, $p_header[&apos;filename_len&apos;]);
        } else {
            $p_header[&apos;filename&apos;] = &apos;&apos;;
        }

        // ----- Get extra
        if ($p_header[&apos;extra_len&apos;] != 0) {
            $p_header[&apos;extra&apos;] = fread($this-&gt;zip_fd, $p_header[&apos;extra_len&apos;]);
        } else {
            $p_header[&apos;extra&apos;] = &apos;&apos;;
        }

        // ----- Get comment
        if ($p_header[&apos;comment_len&apos;] != 0) {
            $p_header[&apos;comment&apos;] = fread($this-&gt;zip_fd, $p_header[&apos;comment_len&apos;]);
        } else {
            $p_header[&apos;comment&apos;] = &apos;&apos;;
        }

        // ----- Extract properties

        // ----- Recuperate date in UNIX format
        //if ($p_header[&apos;mdate&apos;] &amp;&amp; $p_header[&apos;mtime&apos;])
        // TBC : bug : this was ignoring time with 0/0/0
        if (1) {
            // ----- Extract time
            $v_hour    = ($p_header[&apos;mtime&apos;] &amp; 0xF800) &gt;&gt; 11;
            $v_minute  = ($p_header[&apos;mtime&apos;] &amp; 0x07E0) &gt;&gt; 5;
            $v_seconde = ($p_header[&apos;mtime&apos;] &amp; 0x001F) * 2;

            // ----- Extract date
            $v_year  = (($p_header[&apos;mdate&apos;] &amp; 0xFE00) &gt;&gt; 9) + 1980;
            $v_month = ($p_header[&apos;mdate&apos;] &amp; 0x01E0) &gt;&gt; 5;
            $v_day   = $p_header[&apos;mdate&apos;] &amp; 0x001F;

            // ----- Get UNIX date format
            $p_header[&apos;mtime&apos;] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);

        } else {
            $p_header[&apos;mtime&apos;] = time();
        }

        // ----- Set the stored filename
        $p_header[&apos;stored_filename&apos;] = $p_header[&apos;filename&apos;];

        // ----- Set default status to ok
        $p_header[&apos;status&apos;] = &apos;ok&apos;;

        // ----- Look if it is a directory
        if (substr($p_header[&apos;filename&apos;], -1) == &apos;/&apos;) {
            //$p_header[&apos;external&apos;] = 0x41FF0010;
            $p_header[&apos;external&apos;] = 0x00000010;
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privCheckFileHeaders()
    // Description :
    // Parameters :
    // Return Values :
    //   1 on success,
    //   0 on error;
    // --------------------------------------------------------------------------------
    public function privCheckFileHeaders(&amp;$p_local_header, &amp;$p_central_header)
    {
        $v_result = 1;

        // ----- Check the static values
        // TBC
        if ($p_local_header[&apos;filename&apos;] != $p_central_header[&apos;filename&apos;]) {
        }
        if ($p_local_header[&apos;version_extracted&apos;] != $p_central_header[&apos;version_extracted&apos;]) {
        }
        if ($p_local_header[&apos;flag&apos;] != $p_central_header[&apos;flag&apos;]) {
        }
        if ($p_local_header[&apos;compression&apos;] != $p_central_header[&apos;compression&apos;]) {
        }
        if ($p_local_header[&apos;mtime&apos;] != $p_central_header[&apos;mtime&apos;]) {
        }
        if ($p_local_header[&apos;filename_len&apos;] != $p_central_header[&apos;filename_len&apos;]) {
        }

        // ----- Look for flag bit 3
        if (($p_local_header[&apos;flag&apos;] &amp; 8) == 8) {
            $p_local_header[&apos;size&apos;]            = $p_central_header[&apos;size&apos;];
            $p_local_header[&apos;compressed_size&apos;] = $p_central_header[&apos;compressed_size&apos;];
            $p_local_header[&apos;crc&apos;]             = $p_central_header[&apos;crc&apos;];
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privReadEndCentralDir()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privReadEndCentralDir(&amp;$p_central_dir)
    {
        $v_result = 1;

        // ----- Go to the end of the zip file
        $v_size = filesize($this-&gt;zipname);
        @fseek($this-&gt;zip_fd, $v_size);
        if (@ftell($this-&gt;zip_fd) != $v_size) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &apos;Unable to go to the end of the archive \&apos;&apos; . $this-&gt;zipname . &apos;\&apos;&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- First try : look if this is an archive with no commentaries (most of the time)
        // in this case the end of central dir is at 22 bytes of the file end
        $v_found = 0;
        if ($v_size &gt; 26) {
            @fseek($this-&gt;zip_fd, $v_size - 22);
            if (($v_pos = @ftell($this-&gt;zip_fd)) != ($v_size - 22)) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &apos;Unable to seek back to the middle of the archive \&apos;&apos; . $this-&gt;zipname . &apos;\&apos;&apos;);

                // ----- Return
                return PclZip::errorCode();
            }

            // ----- Read for bytes
            $v_binary_data = @fread($this-&gt;zip_fd, 4);
            $v_data        = @unpack(&apos;Vid&apos;, $v_binary_data);

            // ----- Check signature
            if ($v_data[&apos;id&apos;] == 0x06054b50) {
                $v_found = 1;
            }

            $v_pos = ftell($this-&gt;zip_fd);
        }

        // ----- Go back to the maximum possible size of the Central Dir End Record
        if (!$v_found) {
            $v_maximum_size = 65557; // 0xFFFF + 22;
            if ($v_maximum_size &gt; $v_size) {
                $v_maximum_size = $v_size;
            }
            @fseek($this-&gt;zip_fd, $v_size - $v_maximum_size);
            if (@ftell($this-&gt;zip_fd) != ($v_size - $v_maximum_size)) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &apos;Unable to seek back to the middle of the archive \&apos;&apos; . $this-&gt;zipname . &apos;\&apos;&apos;);

                // ----- Return
                return PclZip::errorCode();
            }

            // ----- Read byte per byte in order to find the signature
            $v_pos   = ftell($this-&gt;zip_fd);
            $v_bytes = 0x00000000;
            while ($v_pos &lt; $v_size) {
                // ----- Read a byte
                $v_byte = @fread($this-&gt;zip_fd, 1);

                // -----  Add the byte
                //$v_bytes = ($v_bytes &lt;&lt; 8) | Ord($v_byte);
                // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number
                // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.
                $v_bytes = (($v_bytes &amp; 0xFFFFFF) &lt;&lt; 8) | Ord($v_byte);

                // ----- Compare the bytes
                if ($v_bytes == 0x504b0506) {
                    $v_pos++;
                    break;
                }

                $v_pos++;
            }

            // ----- Look if not found end of central dir
            if ($v_pos == $v_size) {

                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &quot;Unable to find End of Central Dir Record signature&quot;);

                // ----- Return
                return PclZip::errorCode();
            }
        }

        // ----- Read the first 18 bytes of the header
        $v_binary_data = fread($this-&gt;zip_fd, 18);

        // ----- Look for invalid block size
        if (strlen($v_binary_data) != 18) {

            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &quot;Invalid End of Central Dir Record size : &quot; . strlen($v_binary_data));

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Extract the values
        $v_data = unpack(&apos;vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size&apos;, $v_binary_data);

        // ----- Check the global size
        if (($v_pos + $v_data[&apos;comment_size&apos;] + 18) != $v_size) {

            // ----- Removed in release 2.2 see readme file
            // The check of the file size is a little too strict.
            // Some bugs where found when a zip is encrypted/decrypted with &apos;crypt&apos;.
            // While decrypted, zip has training 0 bytes
            if (0) {
                // ----- Error log
                PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, &apos;The central dir is not at the end of the archive.&apos; . &apos; Some trailing bytes exists after the archive.&apos;);

                // ----- Return
                return PclZip::errorCode();
            }
        }

        // ----- Get comment
        if ($v_data[&apos;comment_size&apos;] != 0) {
            $p_central_dir[&apos;comment&apos;] = fread($this-&gt;zip_fd, $v_data[&apos;comment_size&apos;]);
        } else {
            $p_central_dir[&apos;comment&apos;] = &apos;&apos;;
        }

        $p_central_dir[&apos;entries&apos;]      = $v_data[&apos;entries&apos;];
        $p_central_dir[&apos;disk_entries&apos;] = $v_data[&apos;disk_entries&apos;];
        $p_central_dir[&apos;offset&apos;]       = $v_data[&apos;offset&apos;];
        $p_central_dir[&apos;size&apos;]         = $v_data[&apos;size&apos;];
        $p_central_dir[&apos;disk&apos;]         = $v_data[&apos;disk&apos;];
        $p_central_dir[&apos;disk_start&apos;]   = $v_data[&apos;disk_start&apos;];

        // TBC
        //for (reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {
        //}

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privDeleteByRule()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privDeleteByRule(&amp;$p_result_list, &amp;$p_options)
    {
        $v_result      = 1;
        $v_list_detail = array();

        // ----- Open the zip file
        if (($v_result = $this-&gt;privOpenFd(&apos;rb&apos;)) != 1) {
            // ----- Return
            return $v_result;
        }

        // ----- Read the central directory informations
        $v_central_dir = array();
        if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1) {
            $this-&gt;privCloseFd();

            return $v_result;
        }

        // ----- Go to beginning of File
        @rewind($this-&gt;zip_fd);

        // ----- Scan all the files
        // ----- Start at beginning of Central Dir
        $v_pos_entry = $v_central_dir[&apos;offset&apos;];
        @rewind($this-&gt;zip_fd);
        if (@fseek($this-&gt;zip_fd, $v_pos_entry)) {
            // ----- Close the zip file
            $this-&gt;privCloseFd();

            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, &apos;Invalid archive size&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Read each entry
        $v_header_list = array();
        $j_start       = 0;
        for ($i = 0, $v_nb_extracted = 0; $i &lt; $v_central_dir[&apos;entries&apos;]; $i++) {

            // ----- Read the file header
            $v_header_list[$v_nb_extracted] = array();
            if (($v_result = $this-&gt;privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1) {
                // ----- Close the zip file
                $this-&gt;privCloseFd();

                return $v_result;
            }

            // ----- Store the index
            $v_header_list[$v_nb_extracted][&apos;index&apos;] = $i;

            // ----- Look for the specific extract rules
            $v_found = false;

            // ----- Look for extract by name rule
            if ((isset($p_options[PCLZIP_OPT_BY_NAME])) &amp;&amp; ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {

                // ----- Look if the filename is in the list
                for ($j = 0; ($j &lt; sizeof($p_options[PCLZIP_OPT_BY_NAME])) &amp;&amp; (!$v_found); $j++) {

                    // ----- Look for a directory
                    if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == &quot;/&quot;) {

                        // ----- Look if the directory is in the filename path
                        if ((strlen($v_header_list[$v_nb_extracted][&apos;stored_filename&apos;]) &gt; strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) &amp;&amp; (substr($v_header_list[$v_nb_extracted][&apos;stored_filename&apos;], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {
                            $v_found = true;
                        } elseif ((($v_header_list[$v_nb_extracted][&apos;external&apos;] &amp; 0x00000010) == 0x00000010) /* Indicates a folder */ &amp;&amp; ($v_header_list[$v_nb_extracted][&apos;stored_filename&apos;] . &apos;/&apos; == $p_options[PCLZIP_OPT_BY_NAME][$j])) {
                            $v_found = true;
                        }

                    // ----- Look for a filename
                    } elseif ($v_header_list[$v_nb_extracted][&apos;stored_filename&apos;] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {
                        $v_found = true;
                    }
                }

            // ----- Look for extract by ereg rule
            // ereg() is deprecated with PHP 5.3
            /*
            elseif (   (isset($p_options[PCLZIP_OPT_BY_EREG]))
            &amp;&amp; ($p_options[PCLZIP_OPT_BY_EREG] != &quot;&quot;)) {

            if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted][&apos;stored_filename&apos;])) {
            $v_found = true;
            }
            }
            */

            // ----- Look for extract by preg rule
            } elseif ((isset($p_options[PCLZIP_OPT_BY_PREG])) &amp;&amp; ($p_options[PCLZIP_OPT_BY_PREG] != &quot;&quot;)) {

                if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted][&apos;stored_filename&apos;])) {
                    $v_found = true;
                }

            // ----- Look for extract by index rule
            } elseif ((isset($p_options[PCLZIP_OPT_BY_INDEX])) &amp;&amp; ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {

                // ----- Look if the index is in the list
                for ($j = $j_start; ($j &lt; sizeof($p_options[PCLZIP_OPT_BY_INDEX])) &amp;&amp; (!$v_found); $j++) {

                    if (($i &gt;= $p_options[PCLZIP_OPT_BY_INDEX][$j][&apos;start&apos;]) &amp;&amp; ($i &lt;= $p_options[PCLZIP_OPT_BY_INDEX][$j][&apos;end&apos;])) {
                        $v_found = true;
                    }
                    if ($i &gt;= $p_options[PCLZIP_OPT_BY_INDEX][$j][&apos;end&apos;]) {
                        $j_start = $j + 1;
                    }

                    if ($p_options[PCLZIP_OPT_BY_INDEX][$j][&apos;start&apos;] &gt; $i) {
                        break;
                    }
                }
            } else {
                $v_found = true;
            }

            // ----- Look for deletion
            if ($v_found) {
                unset($v_header_list[$v_nb_extracted]);
            } else {
                $v_nb_extracted++;
            }
        }

        // ----- Look if something need to be deleted
        if ($v_nb_extracted &gt; 0) {

            // ----- Creates a temporay file
            $v_zip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid(&apos;pclzip-&apos;) . &apos;.tmp&apos;;

            // ----- Creates a temporary zip archive
            $v_temp_zip = new PclZip($v_zip_temp_name);

            // ----- Open the temporary zip file in write mode
            if (($v_result = $v_temp_zip-&gt;privOpenFd(&apos;wb&apos;)) != 1) {
                $this-&gt;privCloseFd();

                // ----- Return
                return $v_result;
            }

            // ----- Look which file need to be kept
            for ($i = 0; $i &lt; sizeof($v_header_list); $i++) {

                // ----- Calculate the position of the header
                @rewind($this-&gt;zip_fd);
                if (@fseek($this-&gt;zip_fd, $v_header_list[$i][&apos;offset&apos;])) {
                    // ----- Close the zip file
                    $this-&gt;privCloseFd();
                    $v_temp_zip-&gt;privCloseFd();
                    @unlink($v_zip_temp_name);

                    // ----- Error log
                    PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, &apos;Invalid archive size&apos;);

                    // ----- Return
                    return PclZip::errorCode();
                }

                // ----- Read the file header
                $v_local_header = array();
                if (($v_result = $this-&gt;privReadFileHeader($v_local_header)) != 1) {
                    // ----- Close the zip file
                    $this-&gt;privCloseFd();
                    $v_temp_zip-&gt;privCloseFd();
                    @unlink($v_zip_temp_name);

                    // ----- Return
                    return $v_result;
                }

                // ----- Check that local file header is same as central file header
                if ($this-&gt;privCheckFileHeaders($v_local_header, $v_header_list[$i]) != 1) {
                    // TBC
                }
                unset($v_local_header);

                // ----- Write the file header
                if (($v_result = $v_temp_zip-&gt;privWriteFileHeader($v_header_list[$i])) != 1) {
                    // ----- Close the zip file
                    $this-&gt;privCloseFd();
                    $v_temp_zip-&gt;privCloseFd();
                    @unlink($v_zip_temp_name);

                    // ----- Return
                    return $v_result;
                }

                // ----- Read/write the data block
                if (($v_result = PclZipUtilCopyBlock($this-&gt;zip_fd, $v_temp_zip-&gt;zip_fd, $v_header_list[$i][&apos;compressed_size&apos;])) != 1) {
                    // ----- Close the zip file
                    $this-&gt;privCloseFd();
                    $v_temp_zip-&gt;privCloseFd();
                    @unlink($v_zip_temp_name);

                    // ----- Return
                    return $v_result;
                }
            }

            // ----- Store the offset of the central dir
            $v_offset = @ftell($v_temp_zip-&gt;zip_fd);

            // ----- Re-Create the Central Dir files header
            for ($i = 0; $i &lt; sizeof($v_header_list); $i++) {
                // ----- Create the file header
                if (($v_result = $v_temp_zip-&gt;privWriteCentralFileHeader($v_header_list[$i])) != 1) {
                    $v_temp_zip-&gt;privCloseFd();
                    $this-&gt;privCloseFd();
                    @unlink($v_zip_temp_name);

                    // ----- Return
                    return $v_result;
                }

                // ----- Transform the header to a &apos;usable&apos; info
                $v_temp_zip-&gt;privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);
            }

            // ----- Zip file comment
            $v_comment = &apos;&apos;;
            if (isset($p_options[PCLZIP_OPT_COMMENT])) {
                $v_comment = $p_options[PCLZIP_OPT_COMMENT];
            }

            // ----- Calculate the size of the central header
            $v_size = @ftell($v_temp_zip-&gt;zip_fd) - $v_offset;

            // ----- Create the central dir footer
            if (($v_result = $v_temp_zip-&gt;privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {
                // ----- Reset the file list
                unset($v_header_list);
                $v_temp_zip-&gt;privCloseFd();
                $this-&gt;privCloseFd();
                @unlink($v_zip_temp_name);

                // ----- Return
                return $v_result;
            }

            // ----- Close
            $v_temp_zip-&gt;privCloseFd();
            $this-&gt;privCloseFd();

            // ----- Delete the zip file
            // TBC : I should test the result ...
            @unlink($this-&gt;zipname);

            // ----- Rename the temporary file
            // TBC : I should test the result ...
            //@rename($v_zip_temp_name, $this-&gt;zipname);
            PclZipUtilRename($v_zip_temp_name, $this-&gt;zipname);

            // ----- Destroy the temporary archive
            unset($v_temp_zip);

        // ----- Remove every files : reset the file
        } elseif ($v_central_dir[&apos;entries&apos;] != 0) {
            $this-&gt;privCloseFd();

            if (($v_result = $this-&gt;privOpenFd(&apos;wb&apos;)) != 1) {
                return $v_result;
            }

            if (($v_result = $this-&gt;privWriteCentralHeader(0, 0, 0, &apos;&apos;)) != 1) {
                return $v_result;
            }

            $this-&gt;privCloseFd();
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privDirCheck()
    // Description :
    //   Check if a directory exists, if not it creates it and all the parents directory
    //   which may be useful.
    // Parameters :
    //   $p_dir : Directory path to check.
    // Return Values :
    //    1 : OK
    //   -1 : Unable to create directory
    // --------------------------------------------------------------------------------
    public function privDirCheck($p_dir, $p_is_dir = false)
    {
        $v_result = 1;

        // ----- Remove the final &apos;/&apos;
        if (($p_is_dir) &amp;&amp; (substr($p_dir, -1) == &apos;/&apos;)) {
            $p_dir = substr($p_dir, 0, strlen($p_dir) - 1);
        }

        // ----- Check the directory availability
        if ((is_dir($p_dir)) || ($p_dir == &quot;&quot;)) {
            return 1;
        }

        // ----- Extract parent directory
        $p_parent_dir = dirname($p_dir);

        // ----- Just a check
        if ($p_parent_dir != $p_dir) {
            // ----- Look for parent directory
            if ($p_parent_dir != &quot;&quot;) {
                if (($v_result = $this-&gt;privDirCheck($p_parent_dir)) != 1) {
                    return $v_result;
                }
            }
        }

        // ----- Create the directory
        if (!@mkdir($p_dir, 0777)) {
            // ----- Error log
            PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, &quot;Unable to create directory &apos;$p_dir&apos;&quot;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privMerge()
    // Description :
    //   If $p_archive_to_add does not exist, the function exit with a success result.
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privMerge(&amp;$p_archive_to_add)
    {
        $v_result = 1;

        // ----- Look if the archive_to_add exists
        if (!is_file($p_archive_to_add-&gt;zipname)) {

            // ----- Nothing to merge, so merge is a success
            $v_result = 1;

            // ----- Return
            return $v_result;
        }

        // ----- Look if the archive exists
        if (!is_file($this-&gt;zipname)) {

            // ----- Do a duplicate
            $v_result = $this-&gt;privDuplicate($p_archive_to_add-&gt;zipname);

            // ----- Return
            return $v_result;
        }

        // ----- Open the zip file
        if (($v_result = $this-&gt;privOpenFd(&apos;rb&apos;)) != 1) {
            // ----- Return
            return $v_result;
        }

        // ----- Read the central directory informations
        $v_central_dir = array();
        if (($v_result = $this-&gt;privReadEndCentralDir($v_central_dir)) != 1) {
            $this-&gt;privCloseFd();

            return $v_result;
        }

        // ----- Go to beginning of File
        @rewind($this-&gt;zip_fd);

        // ----- Open the archive_to_add file
        if (($v_result = $p_archive_to_add-&gt;privOpenFd(&apos;rb&apos;)) != 1) {
            $this-&gt;privCloseFd();

            // ----- Return
            return $v_result;
        }

        // ----- Read the central directory informations
        $v_central_dir_to_add = array();
        if (($v_result = $p_archive_to_add-&gt;privReadEndCentralDir($v_central_dir_to_add)) != 1) {
            $this-&gt;privCloseFd();
            $p_archive_to_add-&gt;privCloseFd();

            return $v_result;
        }

        // ----- Go to beginning of File
        @rewind($p_archive_to_add-&gt;zip_fd);

        // ----- Creates a temporay file
        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR . uniqid(&apos;pclzip-&apos;) . &apos;.tmp&apos;;

        // ----- Open the temporary file in write mode
        if (($v_zip_temp_fd = @fopen($v_zip_temp_name, &apos;wb&apos;)) == 0) {
            $this-&gt;privCloseFd();
            $p_archive_to_add-&gt;privCloseFd();

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open temporary file \&apos;&apos; . $v_zip_temp_name . &apos;\&apos; in binary write mode&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Copy the files from the archive to the temporary file
        // TBC : Here I should better append the file and go back to erase the central dir
        $v_size = $v_central_dir[&apos;offset&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = fread($this-&gt;zip_fd, $v_read_size);
            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Copy the files from the archive_to_add into the temporary file
        $v_size = $v_central_dir_to_add[&apos;offset&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = fread($p_archive_to_add-&gt;zip_fd, $v_read_size);
            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Store the offset of the central dir
        $v_offset = @ftell($v_zip_temp_fd);

        // ----- Copy the block of file headers from the old archive
        $v_size = $v_central_dir[&apos;size&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @fread($this-&gt;zip_fd, $v_read_size);
            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Copy the block of file headers from the archive_to_add
        $v_size = $v_central_dir_to_add[&apos;size&apos;];
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @fread($p_archive_to_add-&gt;zip_fd, $v_read_size);
            @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Merge the file comments
        $v_comment = $v_central_dir[&apos;comment&apos;] . &apos; &apos; . $v_central_dir_to_add[&apos;comment&apos;];

        // ----- Calculate the size of the (new) central header
        $v_size = @ftell($v_zip_temp_fd) - $v_offset;

        // ----- Swap the file descriptor
        // Here is a trick : I swap the temporary fd with the zip fd, in order to use
        // the following methods on the temporary fil and not the real archive fd
        $v_swap        = $this-&gt;zip_fd;
        $this-&gt;zip_fd  = $v_zip_temp_fd;
        $v_zip_temp_fd = $v_swap;

        // ----- Create the central dir footer
        if (($v_result = $this-&gt;privWriteCentralHeader($v_central_dir[&apos;entries&apos;] + $v_central_dir_to_add[&apos;entries&apos;], $v_size, $v_offset, $v_comment)) != 1) {
            $this-&gt;privCloseFd();
            $p_archive_to_add-&gt;privCloseFd();
            @fclose($v_zip_temp_fd);
            $this-&gt;zip_fd = null;

            // ----- Reset the file list
            unset($v_header_list);

            // ----- Return
            return $v_result;
        }

        // ----- Swap back the file descriptor
        $v_swap        = $this-&gt;zip_fd;
        $this-&gt;zip_fd  = $v_zip_temp_fd;
        $v_zip_temp_fd = $v_swap;

        // ----- Close
        $this-&gt;privCloseFd();
        $p_archive_to_add-&gt;privCloseFd();

        // ----- Close the temporary file
        @fclose($v_zip_temp_fd);

        // ----- Delete the zip file
        // TBC : I should test the result ...
        @unlink($this-&gt;zipname);

        // ----- Rename the temporary file
        // TBC : I should test the result ...
        //@rename($v_zip_temp_name, $this-&gt;zipname);
        PclZipUtilRename($v_zip_temp_name, $this-&gt;zipname);

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privDuplicate()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privDuplicate($p_archive_filename)
    {
        $v_result = 1;

        // ----- Look if the $p_archive_filename exists
        if (!is_file($p_archive_filename)) {

            // ----- Nothing to duplicate, so duplicate is a success.
            $v_result = 1;

            // ----- Return
            return $v_result;
        }

        // ----- Open the zip file
        if (($v_result = $this-&gt;privOpenFd(&apos;wb&apos;)) != 1) {
            // ----- Return
            return $v_result;
        }

        // ----- Open the temporary file in write mode
        if (($v_zip_temp_fd = @fopen($p_archive_filename, &apos;rb&apos;)) == 0) {
            $this-&gt;privCloseFd();

            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, &apos;Unable to open archive file \&apos;&apos; . $p_archive_filename . &apos;\&apos; in binary write mode&apos;);

            // ----- Return
            return PclZip::errorCode();
        }

        // ----- Copy the files from the archive to the temporary file
        // TBC : Here I should better append the file and go back to erase the central dir
        $v_size = filesize($p_archive_filename);
        while ($v_size != 0) {
            $v_read_size = ($v_size &lt; PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = fread($v_zip_temp_fd, $v_read_size);
            @fwrite($this-&gt;zip_fd, $v_buffer, $v_read_size);
            $v_size -= $v_read_size;
        }

        // ----- Close
        $this-&gt;privCloseFd();

        // ----- Close the temporary file
        @fclose($v_zip_temp_fd);

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privErrorLog()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function privErrorLog($p_error_code = 0, $p_error_string = &apos;&apos;)
    {
        if (PCLZIP_ERROR_EXTERNAL == 1) {
            PclError($p_error_code, $p_error_string);
        } else {
            $this-&gt;error_code   = $p_error_code;
            $this-&gt;error_string = $p_error_string;
        }
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privErrorReset()
    // Description :
    // Parameters :
    // --------------------------------------------------------------------------------
    public function privErrorReset()
    {
        if (PCLZIP_ERROR_EXTERNAL == 1) {
            PclErrorReset();
        } else {
            $this-&gt;error_code   = 0;
            $this-&gt;error_string = &apos;&apos;;
        }
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privDisableMagicQuotes()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privDisableMagicQuotes()
    {
        $v_result = 1;

        // ----- Look if function exists
        if ((!function_exists(&quot;get_magic_quotes_runtime&quot;)) || (!function_exists(&quot;set_magic_quotes_runtime&quot;))) {
            return $v_result;
        }

        // ----- Look if already done
        if ($this-&gt;magic_quotes_status != -1) {
            return $v_result;
        }

        // ----- Get and memorize the magic_quote value
        $this-&gt;magic_quotes_status = @get_magic_quotes_runtime();

        // ----- Disable magic_quotes
        if ($this-&gt;magic_quotes_status == 1) {
            @set_magic_quotes_runtime(0);
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------

    // --------------------------------------------------------------------------------
    // Function : privSwapBackMagicQuotes()
    // Description :
    // Parameters :
    // Return Values :
    // --------------------------------------------------------------------------------
    public function privSwapBackMagicQuotes()
    {
        $v_result = 1;

        // ----- Look if function exists
        if ((!function_exists(&quot;get_magic_quotes_runtime&quot;)) || (!function_exists(&quot;set_magic_quotes_runtime&quot;))) {
            return $v_result;
        }

        // ----- Look if something to do
        if ($this-&gt;magic_quotes_status != -1) {
            return $v_result;
        }

        // ----- Swap back magic_quotes
        if ($this-&gt;magic_quotes_status == 1) {
            @set_magic_quotes_runtime($this-&gt;magic_quotes_status);
        }

        // ----- Return
        return $v_result;
    }
    // --------------------------------------------------------------------------------
}

// End of class
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Function : PclZipUtilPathReduction()
// Description :
// Parameters :
// Return Values :
// --------------------------------------------------------------------------------
function PclZipUtilPathReduction($p_dir)
{
    $v_result = &quot;&quot;;

    // ----- Look for not empty path
    if ($p_dir != &quot;&quot;) {
        // ----- Explode path by directory names
        $v_list = explode(&quot;/&quot;, $p_dir);

        // ----- Study directories from last to first
        $v_skip = 0;
        for ($i = sizeof($v_list) - 1; $i &gt;= 0; $i--) {
            // ----- Look for current path
            if ($v_list[$i] == &quot;.&quot;) {
                // ----- Ignore this directory
                // Should be the first $i=0, but no check is done
            } elseif ($v_list[$i] == &quot;..&quot;) {
                $v_skip++;
            } elseif ($v_list[$i] == &quot;&quot;) {
                // ----- First &apos;/&apos; i.e. root slash
                if ($i == 0) {
                    $v_result = &quot;/&quot; . $v_result;
                    if ($v_skip &gt; 0) {
                        // ----- It is an invalid path, so the path is not modified
                        // TBC
                        $v_result = $p_dir;
                        $v_skip   = 0;
                    }

                // ----- Last &apos;/&apos; i.e. indicates a directory
                } elseif ($i == (sizeof($v_list) - 1)) {
                    $v_result = $v_list[$i];

                // ----- Double &apos;/&apos; inside the path
                } else {
                    // ----- Ignore only the double &apos;//&apos; in path,
                    // but not the first and last &apos;/&apos;
                }
            } else {
                // ----- Look for item to skip
                if ($v_skip &gt; 0) {
                    $v_skip--;
                } else {
                    $v_result = $v_list[$i] . ($i != (sizeof($v_list) - 1) ? &quot;/&quot; . $v_result : &quot;&quot;);
                }
            }
        }

        // ----- Look for skip
        if ($v_skip &gt; 0) {
            while ($v_skip &gt; 0) {
                $v_result = &apos;../&apos; . $v_result;
                $v_skip--;
            }
        }
    }

    // ----- Return
    return $v_result;
}
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Function : PclZipUtilPathInclusion()
// Description :
//   This function indicates if the path $p_path is under the $p_dir tree. Or,
//   said in an other way, if the file or sub-dir $p_path is inside the dir
//   $p_dir.
//   The function indicates also if the path is exactly the same as the dir.
//   This function supports path with duplicated &apos;/&apos; like &apos;//&apos;, but does not
//   support &apos;.&apos; or &apos;..&apos; statements.
// Parameters :
// Return Values :
//   0 if $p_path is not inside directory $p_dir
//   1 if $p_path is inside directory $p_dir
//   2 if $p_path is exactly the same as $p_dir
// --------------------------------------------------------------------------------
function PclZipUtilPathInclusion($p_dir, $p_path)
{
    $v_result = 1;

    // ----- Look for path beginning by ./
    if (($p_dir == &apos;.&apos;) || ((strlen($p_dir) &gt;= 2) &amp;&amp; (substr($p_dir, 0, 2) == &apos;./&apos;))) {
        $p_dir = PclZipUtilTranslateWinPath(getcwd(), false) . &apos;/&apos; . substr($p_dir, 1);
    }
    if (($p_path == &apos;.&apos;) || ((strlen($p_path) &gt;= 2) &amp;&amp; (substr($p_path, 0, 2) == &apos;./&apos;))) {
        $p_path = PclZipUtilTranslateWinPath(getcwd(), false) . &apos;/&apos; . substr($p_path, 1);
    }

    // ----- Explode dir and path by directory separator
    $v_list_dir       = explode(&quot;/&quot;, $p_dir);
    $v_list_dir_size  = sizeof($v_list_dir);
    $v_list_path      = explode(&quot;/&quot;, $p_path);
    $v_list_path_size = sizeof($v_list_path);

    // ----- Study directories paths
    $i = 0;
    $j = 0;
    while (($i &lt; $v_list_dir_size) &amp;&amp; ($j &lt; $v_list_path_size) &amp;&amp; ($v_result)) {

        // ----- Look for empty dir (path reduction)
        if ($v_list_dir[$i] == &apos;&apos;) {
            $i++;
            continue;
        }
        if ($v_list_path[$j] == &apos;&apos;) {
            $j++;
            continue;
        }

        // ----- Compare the items
        if (($v_list_dir[$i] != $v_list_path[$j]) &amp;&amp; ($v_list_dir[$i] != &apos;&apos;) &amp;&amp; ($v_list_path[$j] != &apos;&apos;)) {
            $v_result = 0;
        }

        // ----- Next items
        $i++;
        $j++;
    }

    // ----- Look if everything seems to be the same
    if ($v_result) {
        // ----- Skip all the empty items
        while (($j &lt; $v_list_path_size) &amp;&amp; ($v_list_path[$j] == &apos;&apos;)) {
            $j++;
        }
        while (($i &lt; $v_list_dir_size) &amp;&amp; ($v_list_dir[$i] == &apos;&apos;)) {
            $i++;
        }

        if (($i &gt;= $v_list_dir_size) &amp;&amp; ($j &gt;= $v_list_path_size)) {
            // ----- There are exactly the same
            $v_result = 2;
        } elseif ($i &lt; $v_list_dir_size) {
            // ----- The path is shorter than the dir
            $v_result = 0;
        }
    }

    // ----- Return
    return $v_result;
}
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Function : PclZipUtilCopyBlock()
// Description :
// Parameters :
//   $p_mode : read/write compression mode
//             0 : src &amp; dest normal
//             1 : src gzip, dest normal
//             2 : src normal, dest gzip
//             3 : src &amp; dest gzip
// Return Values :
// --------------------------------------------------------------------------------
function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode = 0)
{
    $v_result = 1;

    if ($p_mode == 0) {
        while ($p_size != 0) {
            $v_read_size = ($p_size &lt; PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @fread($p_src, $v_read_size);
            @fwrite($p_dest, $v_buffer, $v_read_size);
            $p_size -= $v_read_size;
        }
    } elseif ($p_mode == 1) {
        while ($p_size != 0) {
            $v_read_size = ($p_size &lt; PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @gzread($p_src, $v_read_size);
            @fwrite($p_dest, $v_buffer, $v_read_size);
            $p_size -= $v_read_size;
        }
    } elseif ($p_mode == 2) {
        while ($p_size != 0) {
            $v_read_size = ($p_size &lt; PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @fread($p_src, $v_read_size);
            @gzwrite($p_dest, $v_buffer, $v_read_size);
            $p_size -= $v_read_size;
        }
    } elseif ($p_mode == 3) {
        while ($p_size != 0) {
            $v_read_size = ($p_size &lt; PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer    = @gzread($p_src, $v_read_size);
            @gzwrite($p_dest, $v_buffer, $v_read_size);
            $p_size -= $v_read_size;
        }
    }

    // ----- Return
    return $v_result;
}
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Function : PclZipUtilRename()
// Description :
//   This function tries to do a simple rename() function. If it fails, it
//   tries to copy the $p_src file in a new $p_dest file and then unlink the
//   first one.
// Parameters :
//   $p_src : Old filename
//   $p_dest : New filename
// Return Values :
//   1 on success, 0 on failure.
// --------------------------------------------------------------------------------
function PclZipUtilRename($p_src, $p_dest)
{
    $v_result = 1;

    // ----- Try to rename the files
    if (!@rename($p_src, $p_dest)) {

        // ----- Try to copy &amp; unlink the src
        if (!@copy($p_src, $p_dest)) {
            $v_result = 0;
        } elseif (!@unlink($p_src)) {
            $v_result = 0;
        }
    }

    // ----- Return
    return $v_result;
}
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Function : PclZipUtilOptionText()
// Description :
//   Translate option value in text. Mainly for debug purpose.
// Parameters :
//   $p_option : the option value.
// Return Values :
//   The option text value.
// --------------------------------------------------------------------------------
function PclZipUtilOptionText($p_option)
{

    $v_list = get_defined_constants();
    for (reset($v_list); $v_key = key($v_list); next($v_list)) {
        $v_prefix = substr($v_key, 0, 10);
        if ((($v_prefix == &apos;PCLZIP_OPT&apos;) || ($v_prefix == &apos;PCLZIP_CB_&apos;) || ($v_prefix == &apos;PCLZIP_ATT&apos;)) &amp;&amp; ($v_list[$v_key] == $p_option)) {
            return $v_key;
        }
    }

    $v_result = &apos;Unknown&apos;;

    return $v_result;
}
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// Function : PclZipUtilTranslateWinPath()
// Description :
//   Translate windows path by replacing &apos;\&apos; by &apos;/&apos; and optionally removing
//   drive letter.
// Parameters :
//   $p_path : path to translate.
//   $p_remove_disk_letter : true | false
// Return Values :
//   The path translated.
// --------------------------------------------------------------------------------
function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter = true)
{
    if (stristr(php_uname(), &apos;windows&apos;)) {
        // ----- Look for potential disk letter
        if (($p_remove_disk_letter) &amp;&amp; (($v_position = strpos($p_path, &apos;:&apos;)) != false)) {
            $p_path = substr($p_path, $v_position + 1);
        }
        // ----- Change potential windows directory separator
        if ((strpos($p_path, &apos;\\&apos;) &gt; 0) || (substr($p_path, 0, 1) == &apos;\\&apos;)) {
            $p_path = strtr($p_path, &apos;\\&apos;, &apos;/&apos;);
        }
    }

    return $p_path;
}
// --------------------------------------------------------------------------------
</code></pre>
                                
                                </section>
                            
                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="webshell.html" class="navigation navigation-next navigation-unique" aria-label="Next page: PHPshell">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"PHP打包源码","level":"1.6.2.1","depth":3,"next":{"title":"PHPshell","level":"1.6.2.2","depth":3,"path":"notepad/webshell.md","ref":"./notepad/webshell.md","articles":[]},"previous":{"title":"后门","level":"1.6.2","depth":2,"ref":"","articles":[{"title":"PHP打包源码","level":"1.6.2.1","depth":3,"path":"notepad/php-zip.md","ref":"./notepad/php-zip.md","articles":[]},{"title":"PHPshell","level":"1.6.2.2","depth":3,"path":"notepad/webshell.md","ref":"./notepad/webshell.md","articles":[]},{"title":"xss脚本","level":"1.6.2.3","depth":3,"path":"notepad/xss.md","ref":"./notepad/xss.md","articles":[]}]},"dir":"ltr"},"config":{"plugins":["fontsettings","-sharing","-lunr","-search","highlight","livereload","expandable-chapters","disqus"],"styles":{},"pluginsConfig":{"disqus":{"useIdentifier":false,"shortName":"webpack"},"livereload":{},"search":{"maxIndexSize":100000},"mathjax-commonhtml":{"defaultScaling":false},"lunr":{"maxIndexSize":1000000000},"fontsettings":{"family":"sans","size":2,"theme":"white"},"highlight":{},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"expandable-chapters":{}},"theme":"default","author":"","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Blog","language":"zh-hans","links":{"sidebar":{"webpack":"https://webpack.weapp.cc/webpack/index.html"}},"gitbook":"*","description":""},"file":{"path":"notepad/php-zip.md","mtime":"2019-03-29T00:31:28.397Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-05-31T01:42:44.729Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-expandable-chapters/expandable-chapters.js"></script>
        
    
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/URI.js/1.16.1/URI.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-disqus/plugin.js"></script>
        
    

    </body>
</html>

